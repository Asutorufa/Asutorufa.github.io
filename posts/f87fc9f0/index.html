<!DOCTYPE html><html class="theme-next gemini" lang="en,ja,zh-Hans,default"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#FFF0F5"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="icon" type="image/png" sizes="16x16" href="https://github.com/asutorufa.png?v=5.1.3"><meta name="keywords" content="C,English,translate,"><meta name="description" content="原文章 What a C programmer should know about memory提示: 本篇文章的图片都是直接使用原文中的图片的地址,如果无法显示,请挂代理   2007年,Ulrich Drepper写了一篇”每个程序员都应该知道的内存“.是的,虽然这篇文章又细又长,但做到了它所应做到的.很多年后,虚拟内存的概念对于很多人来说仍然难以琢磨,仿佛是某种魔法.我无法抗拒的引用一下."><meta name="keywords" content="C,English,translate"><meta property="og:type" content="article"><meta property="og:title" content="翻译-C程序员所应该知道的内存"><meta property="og:url" content="https://Asutorufa.github.io/posts/f87fc9f0/index.html"><meta property="og:site_name" content="アストルファの幻想郷"><meta property="og:description" content="原文章 What a C programmer should know about memory提示: 本篇文章的图片都是直接使用原文中的图片的地址,如果无法显示,请挂代理   2007年,Ulrich Drepper写了一篇”每个程序员都应该知道的内存“.是的,虽然这篇文章又细又长,但做到了它所应做到的.很多年后,虚拟内存的概念对于很多人来说仍然难以琢磨,仿佛是某种魔法.我无法抗拒的引用一下."><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg=="><meta property="og:updated_time" content="2020-05-03T16:26:24.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="翻译-C程序员所应该知道的内存"><meta name="twitter:description" content="原文章 What a C programmer should know about memory提示: 本篇文章的图片都是直接使用原文中的图片的地址,如果无法显示,请挂代理   2007年,Ulrich Drepper写了一篇”每个程序员都应该知道的内存“.是的,虽然这篇文章又细又长,但做到了它所应做到的.很多年后,虚拟内存的概念对于很多人来说仍然难以琢磨,仿佛是某种魔法.我无法抗拒的引用一下."><meta name="twitter:image" content="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg=="><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.3",sidebar:{position:"right",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!0},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://Asutorufa.github.io/posts/f87fc9f0/"><title>翻译-C程序员所应该知道的内存 | アストルファの幻想郷</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-JN3GB41L9H"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JN3GB41L9H")</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">アストルファの幻想郷</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">やりたくないこともやる</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-friends"><a href="/friends" rel="section"><i class="menu-item-icon fa fa-fw fa-users"></i><br> 好友</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://Asutorufa.github.io/posts/f87fc9f0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="アストルファ"><meta itemprop="description" content><meta itemprop="image" content="https://github.com/asutorufa.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="アストルファの幻想郷"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">翻译-C程序员所应该知道的内存</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T00:26:24+08:00">2020-05-04</time> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2020-05-04T00:26:24+08:00">2020-05-04</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Program/" itemprop="url" rel="index"><span itemprop="name">Program</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>原文章 <a href="https://marek.vavrusa.com/memory/#mmap-fun" target="_blank" rel="noopener">What a C programmer should know about memory</a><br>提示: <strong>本篇文章的图片都是直接使用原文中的图片的地址,如果无法显示,请挂代理</strong></p></blockquote><hr><p>2007年,Ulrich Drepper写了一篇”<a href="http://www.akkadia.org/drepper/cpumemory.pdf" target="_blank" rel="noopener">每个程序员都应该知道的内存</a>“.是的,虽然这篇文章又细又长,但做到了它所应做到的.很多年后,虚拟内存的概念对于很多人来说仍然难以琢磨,仿佛是某种魔法.我无法抗拒的引用一下.很多年后甚至原始文章的有效性也被<a href="https://stackoverflow.com/questions/8126311/what-every-programmer-should-know-about-memory" target="_blank" rel="noopener">质疑</a>,到底发生了什么事?</p><blockquote><p>北桥,这是什么东西?那不是巷战.</p></blockquote><p>我尝试从”学习锁的基本原理”去传达实用的一面(比如:你能做什么)和更多有趣的东西.可以看待这是一个胶水在原始文章和你每天使用的东西之间.例子将使用linux上的C99,但是更多主题将是普遍的.<br>编辑: 虽然我对Windows不了解,但我很乐意联系文章去解释.我会尽全力去提起什么函数是平台特有的,但是再一次我只是一个人.如果你发现出入,请让我知道.<br>事不宜迟，倒一杯咖啡，让我们开始吧。</p><p>译者注:</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">worth one's salt:</span><br><span class="line"><span class="code">    good or competent at the job or profession specified.</span></span><br><span class="line"><span class="code">    ig:"any astrologer worth her salt would have predicted this"</span></span><br><span class="line"></span><br><span class="line">what gives?</span><br><span class="line"><span class="code">    是在英语对话中常用的一句口语</span></span><br><span class="line"><span class="code">    通常用它的时候只有两层意思</span></span><br><span class="line"><span class="code">    一个是What's happening?发生了什么事？</span></span><br><span class="line"><span class="code">    另一个是What is the news?有什么消息？</span></span><br><span class="line"></span><br><span class="line">the practical side</span><br><span class="line"><span class="code">    实用的一面</span></span><br></pre></td></tr></table></figure><h2 id="理解虚拟内存-复杂且神秘"><a href="#理解虚拟内存-复杂且神秘" class="headerlink" title="理解虚拟内存 - 复杂且神秘"></a>理解虚拟内存 - 复杂且神秘</h2><p>除非你要处理一些嵌入系统或内核空间的代码,否则你应该在保护模式下进行.这太棒了,你的程序一定拥有它自己的[虚拟]地址空间.”虚拟”在这里很重要.这意味着,除了其他事情外,你不会被可使用的内存限制,但是也无权获得任何.为了使用这些空间,你不得向操作系统要一些真东西来作后援,这被叫做映射.后援可能是物理内存,也可能是持久性存储.前者也被叫做”匿名映射”.但是,稍安勿躁.<a id="more"></a><br>虚拟内存分配(virtual memory allocator&#x3D;VMA)可以给你所不存在的内存,他只能徒劳的希望你不要去使用它,就像现在的银行.这是过量使用(<a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" target="_blank" rel="noopener">overcommiting</a>),并且也存在有需求的程序(稀疏数组),这也意味着内存分配不能简单的说”不”.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *block = <span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">if</span> (block == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM; <span class="comment">/* Sad :( */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查NULL是一个很好的做法,但也没有曾经那么强大.因为过量使用(overcommiting)的存在,操作系统可能给你的内存分配器分配一个有效的内存指针,但当你去访问时-dang*.这里的dang是有平台差异的,但普遍情况下<a href="http://www.win.tue.nl/~aeb/linux/lk/lk-9.html#ss9.6" target="_blank" rel="noopener">oom(out-of-memory) killer</a>将结束你的程序.</p><p><em>这里过于简单,as timbatron noted,并且将在<a href="https://marek.vavrusa.com/memory/#pagefault" target="_blank" rel="noopener">解释按需分页</a>节解释.但是我想要在研究细节之前先过一遍更普遍的知识.</em></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">the plot thickens</span><br><span class="line"><span class="code">    said to mean that a complicated situation or series of events starts to become even more complicated or mysterious</span></span><br><span class="line"><span class="code">    At this point the plot thickened further. A link emerged between the attempt to kill the Pope and the kidnapping of the American.</span></span><br><span class="line"></span><br><span class="line">guaranteed 美 [ˌɡerənˈtid] 英 [ˌɡærənˈtiːd]</span><br><span class="line"><span class="code">    adj. 必定的，肯定的</span></span><br><span class="line"></span><br><span class="line">bounded 美 ['baundid] 英 [ˈbaʊndɪd]</span><br><span class="line"><span class="code">    有界限的, 有限制的</span></span><br><span class="line"></span><br><span class="line">entitled 美 [ɛnˈtaɪtəld; ɪnˈtaɪtəld] 英 [ɪnˈtaɪtəld]</span><br><span class="line"><span class="code">    adj. 有资格的</span></span><br><span class="line"></span><br><span class="line">hold your horses</span><br><span class="line"></span><br><span class="line"><span class="code">    used to tell someone to stop and consider carefully their decision or opinion about something:</span></span><br><span class="line"><span class="code">    Just hold your horses, Bill! Let's think about this for a moment.</span></span><br><span class="line"><span class="code">    停下來想想，且慢… 稍安勿躁</span></span><br><span class="line"></span><br><span class="line">vain 美 [veɪn] 英 [veɪn]</span><br><span class="line"><span class="code">    adj. 徒劳的</span></span><br><span class="line"></span><br><span class="line">a good practice 一个很好的做法</span><br></pre></td></tr></table></figure><h2 id="绕道-内存布局"><a href="#绕道-内存布局" class="headerlink" title="绕道 - 内存布局"></a>绕道 - 内存布局</h2><p>进程内存的布局已经很好的在Gustavo Duarte所著的<a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" target="_blank" rel="noopener">剖析程序内存中</a>中进行解释,所以我将引用并参考原始文章,我希望这是合理的使用.我只有一点想要吹毛求疵一下,那就是他只讲到了x86-32的内存布局,但是幸运的是在x86-64中并没有多大的变化,只是进程可以使用更多的空间 - 在linux中高达 48 bits.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png" alt="linux内存布局"></p><center>Source: Linux address space layout by <a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" target="_blank" rel="noopener">Gustavo Duarte</a></center><p>这也展示了内存映射段(<code>memory mapping segment</code>&#x3D;MMS)是向下增长的,但是并非总是如此.内存映射段通常开始与(<a href="http://lxr.free-electrons.com/source/mm/mmap.c#L1953" target="_blank" rel="noopener">x86&#x2F;mm&#x2F;mmap.c:113</a>和<a href="http://lxr.free-electrons.com/source/arch/x86/mm/mmap.c#L113" target="_blank" rel="noopener">arch&#x2F;mm&#x2F;mmap.c:1953</a>)一个栈底的随机地址.但也可以开始于栈之上或向栈之上增长当且仅当栈很大或栈无限大,或者兼容布局是被允许的.这重要吗?不,但是这将帮助你理解<a href="https://marek.vavrusa.com/memory/#mmap-fun" target="_blank" rel="noopener">自由地址范围</a>.<br>看那个图表,你可以看到三个不同的变量存放位置:进程数据段(静态存储或堆分配),内存映射段,和栈.让我们从这个开始</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">anatomy 美 [əˈnætəmi] 英 [əˈnætəmɪ]</span><br><span class="line"><span class="code">    n. 解剖学；结构；身体；剖析</span></span><br><span class="line"></span><br><span class="line">quibble 美 [ˈkwɪbəl] 英 [ˈkwɪbəl]</span><br><span class="line"><span class="code">    vi /ˈkwɪbəl/</span></span><br><span class="line"><span class="code">        1.（尤指为搪塞）吹毛求疵，诡辩</span></span><br><span class="line"><span class="code">        2.用双关语；说俏皮话</span></span><br><span class="line"><span class="code">    n /ˈkwɪbəl/</span></span><br><span class="line"><span class="code">        1.（尤指为搪塞）吹毛求疵，抱怨</span></span><br><span class="line"><span class="code">        2.双关语</span></span><br><span class="line"></span><br><span class="line">fair 美 [fɛr] 英 [fɛə]</span><br><span class="line"><span class="code">    合理的</span></span><br><span class="line"></span><br><span class="line">iff [if]</span><br><span class="line"><span class="code">    abbr. (= if and only if) 当且仅当</span></span><br></pre></td></tr></table></figure><h2 id="了解栈分配"><a href="#了解栈分配" class="headerlink" title="了解栈分配"></a>了解栈分配</h2><p>实用腰带(译者注：此处为直译，原文为Utility belt)：</p><ul><li><a href="https://linux.die.net/man/3/alloca" target="_blank" rel="noopener">alloca()-在调用者的栈帧中分配内存</a></li><li><a href="https://linux.die.net/man/2/getrlimit" target="_blank" rel="noopener">getrlimit()-获取&#x2F;设置资源限制</a></li><li><a href="https://linux.die.net/man/2/sigaltstack" target="_blank" rel="noopener">sigaltstack()-设置并且(或)得到信号栈上下文</a></li></ul><p>栈易于理解,所有人都知道如何在栈中创建一个变量,不是吗?<br>这里有两个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stairway = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> heaven[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><p>变量的有效性被范围所限制.在C语言中,这意味着:<code>{}</code>.所以每次出现右花括号时就意味着一个变量的结束.然后这里有<a href="https://linux.die.net/man/3/alloca" target="_blank" rel="noopener">alloca()</a>,允许在当前的栈帧中动态分配内存.栈帧与内存框架(memory frame)(也被叫做物理页(physical page))不同,这是一个简单的可以被放入栈中的数据组(函数,参数,变量…).每当我们在栈顶时,我们可以使用剩余的内存直到达到栈的大小限制.<br>这就是可变长数组(variable-length arrays&#x3D;VLA),以及alloca()的工作方式,但是有一个不同-可变长的数组的有效性被范围限制,alloca将保留内存直到函数返回(或被释放).这不是单纯的语法警察(译者注:原文language lawyering,这节下面有详细翻译),这确实是一个问题如果你在循环中使用alloca,因为你没有任何手段去释放它.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">laugh</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; megatron; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> *res = alloca(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(res, <span class="string">"ha"</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">char</span> vla[<span class="number">2</span>] = &#123;<span class="string">'h'</span>,<span class="string">'a'</span>&#125;</span><br><span class="line">    &#125; <span class="comment">/* vla dies, res lives */</span></span><br><span class="line">&#125; <span class="comment">/* all allocas die */</span></span><br></pre></td></tr></table></figure><p>可变长数组和alloca都不适合大分配,因为你几乎没有控制可用的栈内存并且超过栈限制的分配将导致栈溢出.这里有两种方法,但都不实用.<br>第一个方法就是使用sigaltstack()去抓获<code>SIGSEGV</code>并处理.然而这仅仅是让你抓获到栈溢出.<br>另一个方法是以<code>split-stacks</code>进行编译,顾名思义,这真的就是把单片栈分为较小的栈链表也被叫做<code>stacklets</code>.就我所知,GCC和clang都支持-fsplit-stack选项.理论上这也改善了内存的消耗量并且降低了创建线程的成本 - 因为栈一开始就很小并且按需增长.实际上,预期可能会有兼容性问题,因为他需要一个split-stack链表感知器(译者注:原文aware linker)(如:gold)与split-stack unaware库配合使用,而且还有性能问题(Agis Anastasopoulos的”hot split”在Go中是个很好的<a href="http://agis.io/2014/03/25/contiguous-stacks-in-go.html" target="_blank" rel="noopener">解释</a>)</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Stack Frame 栈帧</span><br><span class="line">digest [ˈdaɪˌdʒɛst]</span><br><span class="line"><span class="code">    理解</span></span><br><span class="line"></span><br><span class="line">a variable dies 变量的结束</span><br><span class="line"></span><br><span class="line">aka = also-known-as</span><br><span class="line"></span><br><span class="line">this is how 这就是...</span><br><span class="line"></span><br><span class="line">means [mēnz]</span><br><span class="line"><span class="code">    名词 手段; 方法; 工具; 办法; 径; 繇; 款</span></span><br><span class="line"></span><br><span class="line">grow on demand 按需增长</span><br><span class="line"></span><br><span class="line">play nice with 配合</span><br><span class="line"></span><br><span class="line">scope 美 [skoʊp] 英 [skəʊp]</span><br><span class="line"><span class="code">    n. 范围，领域；</span></span><br><span class="line"></span><br><span class="line">remaining 其余</span><br></pre></td></tr></table></figure><p><strong>language lawyer</strong> from <a href="https://www.reddit.com/r/cpp/comments/52yd5s/what_does_stroustrup_mean_by_language_lawyers_hes/" target="_blank" rel="noopener">What does Stroustrup mean by ‘language lawyers’? He’s said it more than a few times.</a><br>A language lawyer is generally someone that is familiar enough with the details of the standard that they can quote it chapter and verse in order to answer a question, solve a problem, prove a point, etc. The standard is the ultimate authority on what is and isn’t valid C++, and much like the law it’s written in very technical and precise language that requires some effort to really unpack, so there are several parallels to the field of law.<br>It can have both positive and negative connotations. The idea is that you shouldn’t need to be a language lawyer to be able to learn and use the language. At the same time, having a single document that precisely defines the semantics of the language is a significant advantage that many other languages lack, so the fact that it’s possible to be a language lawyer is not an automatic negative. In order to have compatible implementations it’s necessary to define all the edge conditions and dark corners of the language, even if it results in some truly out there passages of the standard.</p><h2 id="了解堆分配"><a href="#了解堆分配" class="headerlink" title="了解堆分配"></a>了解堆分配</h2><p>Utility belt:</p><ul><li><a href="https://linux.die.net/man/2/sbrk" target="_blank" rel="noopener">brk(), sbrk() - manipulate the data segment size</a></li><li><a href="https://linux.die.net/man/3/malloc" target="_blank" rel="noopener">malloc() family - portable libc memory allocator</a></li></ul><p>堆分配可以简单的看作是移动堆段的结束位置(<a href="https://linux.die.net/man/2/sbrk" target="_blank" rel="noopener">program break</a>)和声明内存在旧位置和新位置之间。到了这一点，堆分配和栈分配一样快(没有分页，假设栈已锁定在内存中)。但是有一只猫(cat)，我的意思是捕获(catch)，该死的(dammit)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *block = sbrk(<span class="number">1024</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure><p>(1)我们不能重新声明未使用的内存块，(2)不是线程安全的，因为堆在线程之间共享，(3)接口很难移植，库不能接触到中断</p><blockquote><p>man 3 sbrk — Various systems use various types for the argument of sbrk(). Common are int, ssize_t, ptrdiff_t, intptr_t.</p></blockquote><p>由于这些原因，libc实现了用于内存分配的集中式接口。实现方式<a href="https://en.wikibooks.org/wiki/C_Programming/C_Reference/stdlib.h/malloc#Implementations" target="_blank" rel="noopener">各不相同</a>，但是它支持线程安全的任意大小的内存分配…但有代价。代价是延迟，因为这里还涉及锁，数据结构保留有关已用&#x2F;可用块的信息以及额外的内存开销。堆也不是唯一使用的，因为内存映射段也经常应用于大内存块。</p><blockquote><p>man 3 malloc — Normally, malloc() allocates memory from the heap, … when allocating blocks of memory larger than<br>MMAP_THRESHOLD, the glibc malloc() implementation allocates the memory as a private anonymous mapping.</p></blockquote><p>因为从<code>start_brk</code>到<code>brk</code>堆总是连续的，所以你不能精确钻取漏洞穿过它并减少数据段大小。想象以下情节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *truck = <span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">char</span> *bike  = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">free</span>(truck);</span><br></pre></td></tr></table></figure><p>堆[分配器]移动<code>brk</code>为<code>truck</code>腾出空间。同样为<code>bike</code>也进行相同的操作。但是在<code>truck</code>释放后，<code>brk</code>也无法降级(向下移)，因为<code>bike</code>占据最高段地址。结论就是你的程序可以重用之前<code>truck</code>的内存，但是不会被交回系统直到<code>bike</code>被释放。<br>假设<code>truck</code>被映射，它将不能处于堆段，并且不能影响程序中断(program break)。不过，这种技巧并不能阻止因小分配(另一种说法也叫“碎片化”)而造成的漏洞。<br>注意<code>free()</code>不总是尝试去缩小数据段，因为这是一个<a href="https://marek.vavrusa.com/memory/#pagefault" target="_blank" rel="noopener">潜在的昂贵操作</a>。这对于长时间运行的程序来说是一个问题，如守护程序。一个GNU的拓展，被叫做<a href="https://linux.die.net/man/3/malloc_trim" target="_blank" rel="noopener">malloc_trim()</a>，用于从堆顶部释放内存，但可能会很慢。它对很多小对象的伤害很大，因此应谨慎使用。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sans [sænz]</span><br><span class="line"><span class="code">    __没有__,在外,外部</span></span><br><span class="line"></span><br><span class="line">portable [ˈpɔːtəbəl]</span><br><span class="line"><span class="code">    可移植的</span></span><br><span class="line"></span><br><span class="line">The cost</span><br><span class="line"><span class="code">    代价</span></span><br><span class="line"></span><br><span class="line">utilised</span><br><span class="line"><span class="code">    adj. 被利用的</span></span><br><span class="line"></span><br><span class="line">exclusively [iks'klu:sivli]</span><br><span class="line"><span class="code">    adv. 独占地，专门地，完全地</span></span><br><span class="line"></span><br><span class="line">contiguous [kənˈtɪgjuəs]</span><br><span class="line"><span class="code">    adj. 邻近的；__连续的__</span></span><br><span class="line"></span><br><span class="line">scenario [səˈnɛriˌoʊ]</span><br><span class="line"><span class="code">    n. __情节__；剧本；方案</span></span><br><span class="line"></span><br><span class="line">reuse [riˈjuz]</span><br><span class="line"><span class="code">    n. 再用，重新使用</span></span><br><span class="line"><span class="code">    v. 再用，重新使用</span></span><br><span class="line"></span><br><span class="line">fragmentation [frægmən'teiʃən]</span><br><span class="line"><span class="code">    碎片</span></span><br><span class="line"></span><br><span class="line">sparingly [ˈspeərɪŋlɪ]</span><br><span class="line"><span class="code">    adv. 拘谨地;朴实地;节俭地</span></span><br></pre></td></tr></table></figure><h2 id="未完待续-不定时接着翻译"><a href="#未完待续-不定时接着翻译" class="headerlink" title="未完待续-不定时接着翻译"></a>未完待续-不定时接着翻译</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conquering [ˈkɒŋkərɪŋ]</span><br><span class="line"><span class="code">    adj /ˈkɒŋkərɪŋ/ 进行征服的</span></span><br></pre></td></tr></table></figure></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> アストルファ</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://Asutorufa.github.io/posts/f87fc9f0/" title="翻译-C程序员所应该知道的内存">https://Asutorufa.github.io/posts/f87fc9f0/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/C/" rel="tag"># C</a> <a href="/tags/English/" rel="tag"># English</a> <a href="/tags/translate/" rel="tag"># translate</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/67c8ee7f/" rel="next" title="解决linux下Realtek ALC295的耳机炸裂声"><i class="fa fa-chevron-left"></i> 解决linux下Realtek ALC295的耳机炸裂声</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/posts/f05986bf/" rel="prev" title="DNS客户端协议详解">DNS客户端协议详解<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div id="gitalk-container"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://github.com/asutorufa.png" alt="アストルファ"><p class="site-author-name" itemprop="name">アストルファ</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">57</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">20</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">71</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Asutorufa" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="/email/" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#理解虚拟内存-复杂且神秘"><span class="nav-number">1.</span> <span class="nav-text">理解虚拟内存 - 复杂且神秘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绕道-内存布局"><span class="nav-number">2.</span> <span class="nav-text">绕道 - 内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#了解栈分配"><span class="nav-number">3.</span> <span class="nav-text">了解栈分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#了解堆分配"><span class="nav-number">4.</span> <span class="nav-text">了解堆分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未完待续-不定时接着翻译"><span class="nav-number">5.</span> <span class="nav-text">未完待续-不定时接着翻译</span></a></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div><div class="for-blur"></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">アストルファ</span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><link rel="stylesheet" href="/lib/gitalk/gitalk.css"><script src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"c800a9b9d97b6bef0dfe",clientSecret:"cb3b257598e1a7b9910007c148a33f0054864ef7",accessToken:"d392150a899ebcfb18f8837f18c2e4a554b25cec",repo:"Asutorufa.github.io",owner:"Asutorufa",admin:["Asutorufa"],id:location.pathname,distractionFreeMode:"true"});gitalk.render("gitalk-container")</script><script type="text/javascript" src="/js/src/local-search.js"></script><script>localSearch("search.xml","/","1","auto")</script><script type="text/javascript" src="/js/src/custom.js"></script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>