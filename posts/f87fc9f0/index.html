<!DOCTYPE html><html class="theme-next gemini use-motion" lang="en,ja,zh-Hans,default"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#FFF0F5"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css" rel="stylesheet" type="text/css"><link rel="icon" type="image/png" sizes="16x16" href="https://github.com/asutorufa.png"><meta name="keywords" content="C,English,translate,"><link rel="alternate" href="/atom.xml" title="Asutorufaのブログ" type="application/atom+xml"><meta name="description" content="原文章 What a C programmer should know about memory 提示: 本篇文章的图片都是直接使用原文中的图片的地址,如果无法显示,请挂代理   2007年,Ulrich Drepper写了一篇&quot;每个程序员都应该知道的内存&quot;.是的,虽然这篇文章又细又长,但做到了它所应做到的.很多年后,虚拟内存的概念对于很多人来说仍然难以琢磨,仿佛是某种魔法."><meta property="og:type" content="article"><meta property="og:title" content="翻译-C程序员所应该知道的内存"><meta property="og:url" content="https://asutorufa.com/posts/f87fc9f0/index.html"><meta property="og:site_name" content="Asutorufaのブログ"><meta property="og:description" content="原文章 What a C programmer should know about memory 提示: 本篇文章的图片都是直接使用原文中的图片的地址,如果无法显示,请挂代理   2007年,Ulrich Drepper写了一篇&quot;每个程序员都应该知道的内存&quot;.是的,虽然这篇文章又细又长,但做到了它所应做到的.很多年后,虚拟内存的概念对于很多人来说仍然难以琢磨,仿佛是某种魔法."><meta property="og:locale"><meta property="og:image" content="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png"><meta property="article:published_time" content="2020-05-04T00:26:24.000Z"><meta property="article:modified_time" content="2020-05-04T00:26:24.000Z"><meta property="article:author" content="Asutorufa"><meta property="article:tag" content="C"><meta property="article:tag" content="English"><meta property="article:tag" content="translate"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"",scheme:"Gemini",version:"5.1.3",sidebar:{position:"right",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!0},fancybox:!1,tabs:!0,motion:{enable:!0,async:!0,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},mermaid:{enable:!0,theme:{light:"default",dark:"dark"}}}</script><link rel="canonical" href="https://asutorufa.com/posts/f87fc9f0/"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8681435945442113" crossorigin="anonymous"></script><title>翻译-C程序员所应该知道的内存 | Asutorufaのブログ</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-JN3GB41L9H"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JN3GB41L9H")</script><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Asutorufaのブログ</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">こんにちは</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-friends"><a href="/friends" rel="section"><i class="menu-item-icon fa fa-fw fa-users"></i><br> 好友</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://asutorufa.com/posts/f87fc9f0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="https://github.com/asutorufa.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Asutorufaのブログ"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">翻译-C程序员所应该知道的内存</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T00:26:24+00:00">2020-05-04</time> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2020-05-04T00:26:24+00:00">2020-05-04</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Program/" itemprop="url" rel="index"><span itemprop="name">Program</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>原文章 <a target="_blank" rel="noopener" href="https://marek.vavrusa.com/memory/#mmap-fun">What a C programmer should know about memory</a><br> 提示: <strong>本篇文章的图片都是直接使用原文中的图片的地址,如果无法显示,请挂代理</strong></p></blockquote><hr><p>2007年,Ulrich Drepper写了一篇&quot;<a target="_blank" rel="noopener" href="http://www.akkadia.org/drepper/cpumemory.pdf">每个程序员都应该知道的内存</a>&quot;.是的,虽然这篇文章又细又长,但做到了它所应做到的.很多年后,虚拟内存的概念对于很多人来说仍然难以琢磨,仿佛是某种魔法.我无法抗拒的引用一下.很多年后甚至原始文章的有效性也被<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8126311/what-every-programmer-should-know-about-memory">质疑</a>,到底发生了什么事?</p><blockquote><p>北桥,这是什么东西?那不是巷战.</p></blockquote><p>我尝试从&quot;学习锁的基本原理&quot;去传达实用的一面(比如:你能做什么)和更多有趣的东西.可以看待这是一个胶水在原始文章和你每天使用的东西之间.例子将使用linux上的C99,但是更多主题将是普遍的.<br> 编辑: 虽然我对Windows不了解,但我很乐意联系文章去解释.我会尽全力去提起什么函数是平台特有的,但是再一次我只是一个人.如果你发现出入,请让我知道.<br> 事不宜迟，倒一杯咖啡，让我们开始吧。</p><p>译者注:</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">worth one's salt:
    good or competent at the job or profession specified.
    ig:"any astrologer worth her salt would have predicted this"

what gives?
    是在英语对话中常用的一句口语
    通常用它的时候只有两层意思
    一个是What's happening?发生了什么事？
    另一个是What is the news?有什么消息？

the practical side
    实用的一面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="理解虚拟内存-复杂且神秘">理解虚拟内存 - 复杂且神秘</h2><p>除非你要处理一些嵌入系统或内核空间的代码,否则你应该在保护模式下进行.这太棒了,你的程序一定拥有它自己的[虚拟]地址空间.“虚拟&quot;在这里很重要.这意味着,除了其他事情外,你不会被可使用的内存限制,但是也无权获得任何.为了使用这些空间,你不得向操作系统要一些真东西来作后援,这被叫做映射.后援可能是物理内存,也可能是持久性存储.前者也被叫做&quot;匿名映射”.但是,稍安勿躁.<span id="more"></span><br> 虚拟内存分配(virtual memory allocator=VMA)可以给你所不存在的内存,他只能徒劳的希望你不要去使用它,就像现在的银行.这是过量使用(<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting">overcommiting</a>),并且也存在有需求的程序(稀疏数组),这也意味着内存分配不能简单的说&quot;不&quot;.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>block <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>block <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span> <span class="token comment">/* Sad :( */</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>检查NULL是一个很好的做法,但也没有曾经那么强大.因为过量使用(overcommiting)的存在,操作系统可能给你的内存分配器分配一个有效的内存指针,但当你去访问时-dang*.这里的dang是有平台差异的,但普遍情况下<a target="_blank" rel="noopener" href="http://www.win.tue.nl/~aeb/linux/lk/lk-9.html#ss9.6">oom(out-of-memory) killer</a>将结束你的程序.</p><p><em>这里过于简单,as timbatron noted,并且将在<a target="_blank" rel="noopener" href="https://marek.vavrusa.com/memory/#pagefault">解释按需分页</a>节解释.但是我想要在研究细节之前先过一遍更普遍的知识.</em></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">the plot thickens
    said to mean that a complicated situation or series of events starts to become even more complicated or mysterious
    At this point the plot thickened further. A link emerged between the attempt to kill the Pope and the kidnapping of the American.

guaranteed 美 [ˌɡerənˈtid] 英 [ˌɡærənˈtiːd]
    adj. 必定的，肯定的

bounded 美 ['baundid] 英 [ˈbaʊndɪd]
    有界限的, 有限制的

entitled 美 [ɛnˈtaɪtəld; ɪnˈtaɪtəld] 英 [ɪnˈtaɪtəld]
    adj. 有资格的

hold your horses

<span class="token code keyword">    used to tell someone to stop and consider carefully their decision or opinion about something:
    Just hold your horses, Bill! Let's think about this for a moment.
    停下來想想，且慢… 稍安勿躁</span>

vain 美 [veɪn] 英 [veɪn]
    adj. 徒劳的

a good practice 一个很好的做法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="绕道-内存布局">绕道 - 内存布局</h2><p>进程内存的布局已经很好的在Gustavo Duarte所著的<a target="_blank" rel="noopener" href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/">剖析程序内存中</a>中进行解释,所以我将引用并参考原始文章,我希望这是合理的使用.我只有一点想要吹毛求疵一下,那就是他只讲到了x86-32的内存布局,但是幸运的是在x86-64中并没有多大的变化,只是进程可以使用更多的空间 - 在linux中高达 48 bits.</p><p><img src="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png" alt="linux内存布局" loading="lazy"></p><center>Source: Linux address space layout by <a target="_blank" rel="noopener" href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/">Gustavo Duarte</a></center><p>这也展示了内存映射段(<code>memory mapping segment</code>=MMS)是向下增长的,但是并非总是如此.内存映射段通常开始与(<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/mm/mmap.c#L1953">x86/mm/mmap.c:113</a>和<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/arch/x86/mm/mmap.c#L113">arch/mm/mmap.c:1953</a>)一个栈底的随机地址.但也可以开始于栈之上或向栈之上增长当且仅当栈很大或栈无限大,或者兼容布局是被允许的.这重要吗?不,但是这将帮助你理解<a target="_blank" rel="noopener" href="https://marek.vavrusa.com/memory/#mmap-fun">自由地址范围</a>.<br> 看那个图表,你可以看到三个不同的变量存放位置:进程数据段(静态存储或堆分配),内存映射段,和栈.让我们从这个开始</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">anatomy 美 [əˈnætəmi] 英 [əˈnætəmɪ]
    n. 解剖学；结构；身体；剖析

quibble 美 [ˈkwɪbəl] 英 [ˈkwɪbəl]
    vi /ˈkwɪbəl/
        1.（尤指为搪塞）吹毛求疵，诡辩
        2.用双关语；说俏皮话
    n /ˈkwɪbəl/
        1.（尤指为搪塞）吹毛求疵，抱怨
        2.双关语

fair 美 [fɛr] 英 [fɛə]
    合理的

iff [if]
    abbr. (= if and only if) 当且仅当<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="了解栈分配">了解栈分配</h2><p>实用腰带(译者注：此处为直译，原文为Utility belt)：</p><ul><li><a target="_blank" rel="noopener" href="https://linux.die.net/man/3/alloca">alloca()-在调用者的栈帧中分配内存</a></li><li><a target="_blank" rel="noopener" href="https://linux.die.net/man/2/getrlimit">getrlimit()-获取/设置资源限制</a></li><li><a target="_blank" rel="noopener" href="https://linux.die.net/man/2/sigaltstack">sigaltstack()-设置并且(或)得到信号栈上下文</a></li></ul><p>栈易于理解,所有人都知道如何在栈中创建一个变量,不是吗?<br> 这里有两个例子:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> stairway <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> heaven<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>变量的有效性被范围所限制.在C语言中,这意味着:<code>&#123;&#125;</code>.所以每次出现右花括号时就意味着一个变量的结束.然后这里有<a target="_blank" rel="noopener" href="https://linux.die.net/man/3/alloca">alloca()</a>,允许在当前的栈帧中动态分配内存.栈帧与内存框架(memory frame)(也被叫做物理页(physical page))不同,这是一个简单的可以被放入栈中的数据组(函数,参数,变量…).每当我们在栈顶时,我们可以使用剩余的内存直到达到栈的大小限制.<br> 这就是可变长数组(variable-length arrays=VLA),以及alloca()的工作方式,但是有一个不同-可变长的数组的有效性被范围限制,alloca将保留内存直到函数返回(或被释放).这不是单纯的语法警察(译者注:原文language lawyering,这节下面有详细翻译),这确实是一个问题如果你在循环中使用alloca,因为你没有任何手段去释放它.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">laugh</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> megatron<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">char</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token function">alloca</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">memcpy</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token string">"ha"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">char</span> vla<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token char">'h'</span><span class="token punctuation">,</span><span class="token char">'a'</span><span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span> <span class="token comment">/* vla dies, res lives */</span>
<span class="token punctuation">&#125;</span> <span class="token comment">/* all allocas die */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可变长数组和alloca都不适合大分配,因为你几乎没有控制可用的栈内存并且超过栈限制的分配将导致栈溢出.这里有两种方法,但都不实用.<br> 第一个方法就是使用sigaltstack()去抓获<code>SIGSEGV</code>并处理.然而这仅仅是让你抓获到栈溢出.<br> 另一个方法是以<code>split-stacks</code>进行编译,顾名思义,这真的就是把单片栈分为较小的栈链表也被叫做<code>stacklets</code>.就我所知,GCC和clang都支持-fsplit-stack选项.理论上这也改善了内存的消耗量并且降低了创建线程的成本 - 因为栈一开始就很小并且按需增长.实际上,预期可能会有兼容性问题,因为他需要一个split-stack链表感知器(译者注:原文aware linker)(如:gold)与split-stack unaware库配合使用,而且还有性能问题(Agis Anastasopoulos的&quot;hot split&quot;在Go中是个很好的<a target="_blank" rel="noopener" href="http://agis.io/2014/03/25/contiguous-stacks-in-go.html">解释</a>)</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">Stack Frame 栈帧
digest [ˈdaɪˌdʒɛst]
    理解

a variable dies 变量的结束

aka = also-known-as

this is how 这就是...

means [mēnz]
    名词 手段; 方法; 工具; 办法; 径; 繇; 款

grow on demand 按需增长

play nice with 配合

scope 美 [skoʊp] 英 [skəʊp]
    n. 范围，领域；

remaining 其余<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>language lawyer</strong> from <a target="_blank" rel="noopener" href="https://www.reddit.com/r/cpp/comments/52yd5s/what_does_stroustrup_mean_by_language_lawyers_hes/">What does Stroustrup mean by ‘language lawyers’? He’s said it more than a few times.</a><br> A language lawyer is generally someone that is familiar enough with the details of the standard that they can quote it chapter and verse in order to answer a question, solve a problem, prove a point, etc. The standard is the ultimate authority on what is and isn’t valid C++, and much like the law it’s written in very technical and precise language that requires some effort to really unpack, so there are several parallels to the field of law.<br> It can have both positive and negative connotations. The idea is that you shouldn’t need to be a language lawyer to be able to learn and use the language. At the same time, having a single document that precisely defines the semantics of the language is a significant advantage that many other languages lack, so the fact that it’s possible to be a language lawyer is not an automatic negative. In order to have compatible implementations it’s necessary to define all the edge conditions and dark corners of the language, even if it results in some truly out there passages of the standard.</p><h2 id="了解堆分配">了解堆分配</h2><p>Utility belt:</p><ul><li><a target="_blank" rel="noopener" href="https://linux.die.net/man/2/sbrk">brk(), sbrk() - manipulate the data segment size</a></li><li><a target="_blank" rel="noopener" href="https://linux.die.net/man/3/malloc">malloc() family - portable libc memory allocator</a></li></ul><p>堆分配可以简单的看作是移动堆段的结束位置(<a target="_blank" rel="noopener" href="https://linux.die.net/man/2/sbrk">program break</a>)和声明内存在旧位置和新位置之间。到了这一点，堆分配和栈分配一样快(没有分页，假设栈已锁定在内存中)。但是有一只猫(cat)，我的意思是捕获(catch)，该死的(dammit)。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>block <span class="token operator">=</span> <span class="token function">sbrk</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>(1)我们不能重新声明未使用的内存块，(2)不是线程安全的，因为堆在线程之间共享，(3)接口很难移植，库不能接触到中断</p><blockquote><p>man 3 sbrk — Various systems use various types for the argument of sbrk(). Common are int, ssize_t, ptrdiff_t, intptr_t.</p></blockquote><p>由于这些原因，libc实现了用于内存分配的集中式接口。实现方式<a target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/C_Programming/C_Reference/stdlib.h/malloc#Implementations">各不相同</a>，但是它支持线程安全的任意大小的内存分配…但有代价。代价是延迟，因为这里还涉及锁，数据结构保留有关已用/可用块的信息以及额外的内存开销。堆也不是唯一使用的，因为内存映射段也经常应用于大内存块。</p><blockquote><p>man 3 malloc — Normally, malloc() allocates memory from the heap, … when allocating blocks of memory larger than<br> MMAP_THRESHOLD, the glibc malloc() implementation allocates the memory as a private anonymous mapping.</p></blockquote><p>因为从<code>start_brk</code>到<code>brk</code>堆总是连续的，所以你不能精确钻取漏洞穿过它并减少数据段大小。想象以下情节：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>truck <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>bike  <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">free</span><span class="token punctuation">(</span>truck<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>堆[分配器]移动<code>brk</code>为<code>truck</code>腾出空间。同样为<code>bike</code>也进行相同的操作。但是在<code>truck</code>释放后，<code>brk</code>也无法降级(向下移)，因为<code>bike</code>占据最高段地址。结论就是你的程序可以重用之前<code>truck</code>的内存，但是不会被交回系统直到<code>bike</code>被释放。<br> 假设<code>truck</code>被映射，它将不能处于堆段，并且不能影响程序中断(program break)。不过，这种技巧并不能阻止因小分配(另一种说法也叫“碎片化”)而造成的漏洞。<br> 注意<code>free()</code>不总是尝试去缩小数据段，因为这是一个<a target="_blank" rel="noopener" href="https://marek.vavrusa.com/memory/#pagefault">潜在的昂贵操作</a>。这对于长时间运行的程序来说是一个问题，如守护程序。一个GNU的拓展，被叫做<a target="_blank" rel="noopener" href="https://linux.die.net/man/3/malloc_trim">malloc_trim()</a>，用于从堆顶部释放内存，但可能会很慢。它对很多小对象的伤害很大，因此应谨慎使用。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">sans [sænz]
    <span class="token bold"><span class="token punctuation">__</span><span class="token content">没有</span><span class="token punctuation">__</span></span>,在外,外部

portable [ˈpɔːtəbəl]
    可移植的

The cost
    代价

utilised
    adj. 被利用的

exclusively [iks'klu:sivli]
    adv. 独占地，专门地，完全地

contiguous [kənˈtɪgjuəs]
    adj. 邻近的；<span class="token bold"><span class="token punctuation">__</span><span class="token content">连续的</span><span class="token punctuation">__</span></span>

scenario [səˈnɛriˌoʊ]
    n. <span class="token bold"><span class="token punctuation">__</span><span class="token content">情节</span><span class="token punctuation">__</span></span>；剧本；方案

reuse [riˈjuz]
    n. 再用，重新使用
    v. 再用，重新使用

fragmentation [frægmən'teiʃən]
    碎片

sparingly [ˈspeərɪŋlɪ]
    adv. 拘谨地;朴实地;节俭地<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="未完待续-不定时接着翻译">未完待续-不定时接着翻译</h2><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">conquering [ˈkɒŋkərɪŋ]
    adj /ˈkɒŋkərɪŋ/ 进行征服的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> Asutorufa</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://asutorufa.com/posts/f87fc9f0/" title="翻译-C程序员所应该知道的内存">https://asutorufa.com/posts/f87fc9f0/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/C/" rel="tag"># C</a> <a href="/tags/English/" rel="tag"># English</a> <a href="/tags/translate/" rel="tag"># translate</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/67c8ee7f/" rel="next" title="解决linux下Realtek ALC295的耳机炸裂声"><i class="fa fa-chevron-left"></i> 解决linux下Realtek ALC295的耳机炸裂声</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/posts/f05986bf/" rel="prev" title="DNS客户端协议详解">DNS客户端协议详解<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><ins class="adsbygoogle" style="display:block;margin: 12px 0 12px 0;" data-ad-format="fluid" data-ad-layout-key="-h2+d+5c-9-3e" data-ad-client="ca-pub-8681435945442113" data-ad-slot="8241328770"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><div id="gitalk-container"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://github.com/asutorufa.png" alt=""><p class="site-author-name" itemprop="name"></p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">68</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">23</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">85</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Asutorufa" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="/email/" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-%E5%A4%8D%E6%9D%82%E4%B8%94%E7%A5%9E%E7%A7%98"><span class="nav-number">1.</span> <span class="nav-text">理解虚拟内存 - 复杂且神秘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%95%E9%81%93-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.</span> <span class="nav-text">绕道 - 内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E6%A0%88%E5%88%86%E9%85%8D"><span class="nav-number">3.</span> <span class="nav-text">了解栈分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E5%A0%86%E5%88%86%E9%85%8D"><span class="nav-number">4.</span> <span class="nav-text">了解堆分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD-%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%8E%A5%E7%9D%80%E7%BF%BB%E8%AF%91"><span class="nav-number">5.</span> <span class="nav-text">未完待续-不定时接着翻译</span></a></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div><div class="for-blur"></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Asutorufa</span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js"></script><script type="text/javascript" src="/js/src/motion.js"></script><script type="text/javascript" src="/js/src/affix.js"></script><script type="text/javascript" src="/js/src/schemes/pisces.js"></script><script type="text/javascript" src="/js/src/scrollspy.js"></script><script type="text/javascript" src="/js/src/post-details.js"></script><script type="text/javascript" src="/js/src/bootstrap.js"></script><link rel="stylesheet" href="/lib/gitalk/gitalk.css"><script src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"c800a9b9d97b6bef0dfe",clientSecret:"cb3b257598e1a7b9910007c148a33f0054864ef7",accessToken:"d392150a899ebcfb18f8837f18c2e4a554b25cec",repo:"Asutorufa.github.io",owner:"Asutorufa",admin:["Asutorufa"],id:location.pathname,distractionFreeMode:"true"});gitalk.render("gitalk-container")</script><script type="text/javascript" src="/js/src/local-search.js"></script><script>localSearch("search.xml","/","1","auto")</script><link rel="stylesheet" href="/lib/katex/katex.min.css"><script type="text/javascript" src="/js/src/js.cookie.js"></script><script type="text/javascript" src="/js/src/scroll-cookie.js"></script><script type="text/javascript" src="/lib/mermaid/mermaid.min.js"></script><script type="text/javascript" src="/js/src/mermaid.js"></script><script type="text/javascript" src="/js/src/custom.js"></script></body></html>