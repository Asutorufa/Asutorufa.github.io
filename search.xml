<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[archlinux安装记录]]></title>
    <url>%2Fposts%2Fe3707853%2F</url>
    <content type="text"><![CDATA[详细安装教程请参考arch wiki Installation guide (简体中文),此处只记录安装后遇到的问题. grub更新菜单 1grub-mkconfig -o /boot/grub/grub.cfg 安装os-prober让grub检测到其他系统并自动创建引导 1pacman -S os-prober 使用system-boot(就是直接使用linux内核引导系统,不再需要grub,如果有多系统不推荐,会把efi分区搞得很乱): 123pacman -S efibootmgr dosfstools# 此处注意:此处要把efi分区挂载为/boot,而非平常的/boot/efibootctl install --path=/boot 关于efi的部分可以看我的另一贴. arch 安装应用后 应用菜单不刷新怎么办(这个正常情况是不会遇到的,只是刚装完有些功能不完整会这样,我就遇到了): 1kbuildsycoca5 --noincremental 新增用户[1]:首先添加一个用户，并把它加到wheel组 1useradd -m -G wheel -s /bin/bash [用户名] 然后为这个用户设置密码 1passwd [用户名] 最后设置wheel组的用户能用sudo获取root权限: 1234visudo #找到这样的一行,把前面的#去掉: #%wheel ALL=(ALL) ALL按ESC键，输入x!回车就可以保存并退出 启用dhcp自动获取网络地址,不然开机无法自动联网 1systemctl enable dhcpcd.service 如果只使用有线网络 可以使用Systemd-networkd——以下已包含dhcp的功能,下面两条命令包括上面那个的功能—— 1234pacman -s networkmanagersystemctl enable NetworkManager # 启动这个后开机有个NetworkManager-wait-online会占用大概6s的时间,嫌慢的可以屏蔽systemctl mask NetworkManager-wait-online 安装一个图形界面,比如kde 12pacman -S plasma-desktopsystemctl start sddm.service 一些gtk应用的plasma panel托盘图标模糊且右键菜单比较奇怪解决方法: 安装libappindicator-gtk3 libappindicator-gtk2 1pacman -S libappindicator-gtk3 libappindicator-gtk2 安装一个终端,不然进入图形界面只能进tty输入命令 1pacman -S konsole 蓝牙耳机可能载入模块失败 12pactl load-module module-bluetooth-discoverFailure: Module initialization failed 临时解决方法: 12pactl unload-module module-bluetooth-discoverpactl load-module module-bluetooth-discover 长期解决方法[2]: Edit the file: 1/etc/pulse/default.pa and comment out (with an # at the beginning of the line) the following line: 1#load-module module-bluetooth-discover now edit the file: 1/usr/bin/start-pulseaudio-x11 and after the lines: 123if [ x”$SESSION_MANAGER” != x ] ; then /usr/bin/pactl load-module module-x11-xsmp “display=$DISPLAY session_manager=$SESSION_MANAGER” &gt; /dev/null fi add the following line: 1/usr/bin/pactl load-module module-bluetooth-discover This way the Pulse audio’s Bluetooth modules will not be downloaded at boot time but after x11 is started. 字体优化:有些字体可能看不见,比如 𫔭 𪠸 : 12#安装 ttf-hanazono ttf-ume(mincho) 字体pacman -S ttf-hanazono ttf-ume 不要使用noto和思源黑体的亚洲字体整合包,因为会优先使用日语字体,造成中文大小不一,尽量下载思源黑体的分开的字体包,然后在~/.config/fontconfig/fonts.conf中将中文的思源黑体设置为第一个,具体设置参考Font_configuration 解决DNS污染问题:安装dnscrypt-proxy 具体方法参见arch wiki dnscrypt-proxy,使用dnsmasq-china-list排除中国域名 arch 使用pyhon-dlib会提示Undefined symbol: cblas_dtrsm使用aur或archlinuxcn中的openblas-lapack-git代替pacman源中的cblas,貌似源中的cblas版本太低 自动清除pacman的缓存:创建/usr/share/libalpm/hooks/clean-pacman-cache.hook 1234567891011[Trigger]Operation = RemoveOperation = InstallOperation = UpgradeType = PackageTarget = *[Action]Description = Cleaning up old packages...When = PostTransactionExec = /usr/bin/paccache -rvk3 ext4分区优化: 有备用电源或者笔记本可以关闭ext4的barriers具体方法参考Ext4#Turning_barriers_off deadbeef-git 打开提示plugin cdda.so not found or failed to load解决方法: 安装 libcddb libcdio 1pacman -S libcddb libcdio 使用anime4k会提示缺少openCL库,安装ocl-icd 1pacman -S ocl-icd 开启powertop的自动优化节省电量: 12345678910111213141516#安装powertoppacman -S powertop#开机自动启用vim /etc/systemd/system/powertop.service#填入以下内容[Unit]Description=Powertop tunings[Service]ExecStart=/usr/bin/powertop --auto-tune &amp;&amp; echo 'on' &gt; '/sys/bus/usb/devices/1-1/power/control' &amp;&amp; echo 'on' &gt; '/sys/bus/usb/devices/1-4/power/control' &amp;&amp; echo 'on' &gt; '/sys/bus/usb/devices/usb1/power/control' &amp;&amp; echo 'on' &gt; '/sys/bus/usb/devices/usb2/power/control' &amp;&amp; echo 'on' &gt; '/sys/bus/usb/devices/1-7/power/control'RemainAfterExit=true[Install]WantedBy=multi-user.target# 启用systemctl enable powertop.service 除了第一句,其他命令是禁用usb的休眠,不然鼠标用起来很难受(注意:每个电脑的命令都不同,请自行用powertop查看相应的命令) 12345678910# Autosuspend for USB device USB Optical Mouse [PixArt]echo 'on' &gt; '/sys/bus/usb/devices/1-1/power/control';# Autosuspend for USB device HP Wide Vision HD [Generic]echo 'on' &gt; '/sys/bus/usb/devices/1-4/power/control';# Autosuspend for USB device xHCI Host Controller [usb1]echo 'on' &gt; '/sys/bus/usb/devices/usb1/power/control';# Autosuspend for USB device xHCI Host Controller [usb2]echo 'on' &gt; '/sys/bus/usb/devices/usb2/power/control';# Autosuspend for unknown USB device 1-7 (8087:0a2a)echo 'on' &gt; '/sys/bus/usb/devices/1-7/power/control'; 已知问题: kde discover 无法使用pacman backenddiscover 使用了 packagekit,使用 pkcon 需要root权限,按理来说packagekit会自动获取root且无需输入密码,但discover无法获取root已无法已root用户运行,问题未知,放弃解决解决方法:卸载discover packagekit packagekit-qt5新安装的话 索性不装就行了 此方法参考自 用户添加 此方法参考自 PulseAudio can not load bluetooth module]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
        <tag>efi</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CIDR网络匹配]]></title>
    <url>%2Fposts%2F3cb4313e%2F</url>
    <content type="text"><![CDATA[CIDR我们知道cidr对ip匹配时,只要cidr的mask长度的前几位与要匹配的ip相同,则可以说匹配成功. 12345假设有一个cidr为128.0.0.1/24转换为二进制 1000 0000.0000 0000.0000 0000.0000 0001/24可以知道要匹配ip的前24为与cidr的前24(1000 0000.0000 0000.0000 0000)位相同则匹配成功假设有一个ip 128.0.0.128 二进制为 1000 0000.0000 0000.0000 0000.1000 0000可以看到前24位与cidr相同 则匹配成功 前缀树通过上述规则 我们可以使用前缀树实现CIDR对ip的匹配 12345678 root / \ 0 1 / \ / \ 0 1 0 1 /当ip匹配到此处,此处已无任何子树,且是某一cidr的末尾时则匹配成功若此处节点为null(golang为nil)且不是某一cidr的末尾时则匹配失败 trie树类似上述结构 trie树节点 我们可以这样写+node|- bool(判断是否匹配成功,是否是某一cidr的末尾)|- left(左树代表0)|- right(右树代表1) 使用golang实现123456789101112131415type node struct &#123; isLast bool left *node right *node&#125;type TrieTree struct &#123; root *node&#125;func NewTrieTree() *TrieTree &#123; return &amp;TrieTree&#123; root: &amp;node&#123;&#125;, &#125;&#125; 对每一个CIDR的插入注意: 此处传入的CIDR为CIDR前mask位的二进制形式 12345678910111213141516171819202122func (trie *TrieTree) Insert(str string) &#123; nodeTemp := trie.root for i := 0; i &lt; len(str); i++ &#123; // 1 byte is 49 if str[i] == 49 &#123; if nodeTemp.right == nil &#123; nodeTemp.right = new(node) &#125; nodeTemp = nodeTemp.right &#125; // 0 byte is 48 if str[i] == 48 &#123; if nodeTemp.left == nil &#123; nodeTemp.left = new(node) &#125; nodeTemp = nodeTemp.left &#125; if i == len(str)-1 &#123; nodeTemp.isLast = true &#125; &#125;&#125; 对ip的匹配注意: 此处传入的ip为ip的二进制形式 123456789101112131415161718func (trie *TrieTree) Search(str string) bool &#123; nodeTemp := trie.root for i := 0; i &lt; len(str); i++ &#123; if str[i] == 49 &#123; nodeTemp = nodeTemp.right &#125; if str[i] == 48 &#123; nodeTemp = nodeTemp.left &#125; if nodeTemp == nil &#123; return false &#125; if nodeTemp.isLast == true &#123; return true &#125; &#125; return false&#125; 如果需要知道ip如何转换为二进制,可以联系我]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>CIDR</tag>
        <tag>计算机网络</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang实现子进程后台]]></title>
    <url>%2Fposts%2F89c4c907%2F</url>
    <content type="text"><![CDATA[系统的进程机制linux1234567891011121314151617linux下的进程机制,当父进程被杀死之后,子进程就被系统接管+系统|-父进程 -&gt; system管理|--子进程 -&gt; 父进程管理当父进程被杀死之后+系统|-父进程 -&gt; 被杀死|--子进程 -&gt; system管理如果子进程被杀死,而且父进程没有处理子进程的善后工作,那么子进程就会变成僵尸进程+系统|-父进程 -&gt; system管理|--子进程(被杀死) -&gt; 僵尸进程 windows1234567891011121314151617181920212223windows下的进程机制就不太一样了,当父进程被杀死之后,子进程也会被杀死但是如果子进程还有子进程,杀死子进程但不杀死父进程,子进程的子进程就会被系统接管+系统|-父进程 -&gt; system管理|--子进程 -&gt; 父进程管理|---孙进程 -&gt; 子进程管理当父进程被杀死+系统|-父进程 -&gt; 被杀死|--子进程 -&gt; 被杀死 |---孙进程 -&gt; 被杀死当子进程被杀死+系统|-父进程 -&gt; 系统管理|--子进程 -&gt; 被杀死|-孙进程 -&gt; 系统管理windows的机制和linux不太一样,如果子进程被杀死也不会有僵尸进程这种东西,所以子进程可以放心杀死 实现golang的后台如果想实现golang子进程后台,而且不杀死当前父进程,那么我们至少得创建子进程,子进程创建孙进程,然后杀死子进程,这种方法不管在linux还是windows都可以实现如果使用c语言我们可以使用系统提供的fork,使用double fork实现上述过程golang只提供了forkexec,也就是说一个程序只能创建子进程通过这个我想到了一个比较另类的方法,就是在创建进程的时候再次调用本程序再创建进程,这样就相当于创建了子进程,子进程创建孙进程实现就是给程序加参数,再次调用的时候加上这个参数再创建想要的进程 123456789101112131415func daemonF()&#123; cmd := exec.Command("puthon","-m","http.server") cmd.Start()&#125;func main()&#123; daemon := flag.Bool("d", false, "d") flag.Parse() if *daemon == true &#123; daemonF() &#125; else &#123; nowFunction, _ := filepath.Abs(os.Args[0]) cmd := exec.Command(nowFunction,"-d") cmd.Run() &#125;&#125; 123456比如我们有一个程序叫makebk,有一个参数 -d+系统|-makebk(再次调用makebk并加上参数-d) -&gt; 父进程:system|--makebk -d(加上参数之后再创建想要的进程) -&gt; 父进程:makebk|---子进程 -&gt; 父进程:makebk -d 这样就得到我们想要的三层结构了,这时候让父进程杀死make -d,就实现子进程被系统接管,实现子进程后台]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>linux</tag>
        <tag>go</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uefi and efi]]></title>
    <url>%2Fposts%2Fa99a60b1%2F</url>
    <content type="text"><![CDATA[创建efi分区: 创建efi分区要设置boot flag,而不是纯FAT32文件系统使用gdisk 12gdisk /dev/sd**这里要注意后面输入分区系统编号 要选择EFI分区,目前efi分区编号是 ef00 使用parted 12parted /dev/sd**(parted) set 1 boot on 之后再格式化为fat32 1mkfs.vfat -F 32 /dev/sd** uefi 会查看所有 fat 分区，看看里面有没有 efi 引导文件,然后只要是 FAT32 文件系统就行,所以可以把 windows 或 ubuntu 的 iso 直接解压到一个 fat 分区（比如 fat 的 u 盘或移动硬盘）然后引导有些UEFI系统只会识别 efi分区下的EFI/boot文件夹内的efi文件,有的甚至只会识别EFI/boot/bootx64.efi]]></content>
      <categories>
        <category>efi</category>
      </categories>
      <tags>
        <tag>efi</tag>
        <tag>uefi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习之感知器的实现]]></title>
    <url>%2Fposts%2F64e69c3e%2F</url>
    <content type="text"><![CDATA[感知器的一个公式: 当 wx+b&gt;0 , f(x)=1,否则f(x)=0 x输入的向量 w:是权重 w*x是点积 b是偏置(与权重类似,偏置可以认为是激励函数的偏移量，或者给神经元一个基础活跃等级。) 对权重的调整公式,此处使用了梯度下降的方法: w=w+i*(t-count)*x i是一个常数,i越小感知器学习越精确,当然耗费时间也最长 t:本应该得到的值 count:实际计算得到的值 x:同上 对偏置调整的公式: b=b+i*(t-count) 这次我们使用python来实现与和或 12345678910#因为与和或计算需要输入两个数,所以这里设置两个权重global w1,w2w1=0.4w2=0.6#偏置随便设一个global bb=0.8#上面提到的常数global ii=0.01 对感知器公式实现的函数: 12345def count(x,y): if w1*x+w2*y+b&gt;0: return 1 else: return 0 对权重和偏置不断矫正的函数: 1234567def update_all(r,x,y): global w1,w2,b temp = count(x,y) w1=w1+i*(r-temp)*x w2=w2+i*(r-temp)*y b=b+i*(r-temp) print(w1,w2,b) 最后就是输入学习的资料和确认计算结果: 1234567891011def main(): for _ in range(1,50): update_all(1.0,1.0,1.0) update_all(0.0,1.0,0.0) update_all(0.0,0.0,1.0) update_all(0.0,0.0,0.0) print('1 and 1 =',count(1,1)) print('0 and 1 =',count(0,1)) print('1 and 0 =',count(1,0)) print('0 and 0 =',count(0,0)) 这里我们先进行与的计算:这里我前面代码写错了,所以说下面所有的结果会不一样…..进行25次学习的结果: 123456789101112(0.4, 0.6, 0.8)(0.39, 0.6, 0.79)(0.39, 0.59, 0.78)(0.39, 0.59, 0.77)(0.39, 0.59, 0.77).......省略........(0.1599999999999998, 0.35999999999999976, 0.08999999999999947)(0.1599999999999998, 0.35999999999999976, 0.07999999999999947)('1 and 1 =', 1)('0 and 1 =', 1)('1 and 0 =', 1)('0 and 0 =', 1) 这里我们明显发现结果是错误的,提升到50次: 123456789101112131415(0.4, 0.6, 0.8)(0.39, 0.6, 0.79)(0.39, 0.59, 0.78)(0.39, 0.59, 0.77)(0.39, 0.59, 0.77)(0.38, 0.59, 0.76)(0.38, 0.58, 0.75).......省略........(0.07999999999999981, 0.1799999999999996, -0.18000000000000055)(0.07999999999999981, 0.1799999999999996, -0.18000000000000055)(0.07999999999999981, 0.1799999999999996, -0.18000000000000055)('1 and 1 =', 1)('0 and 1 =', 0)('1 and 0 =', 0)('0 and 0 =', 0) 结果正确了,并且权重和偏置都稳定到一个值,是不是感觉很神奇或运算也是相同的,这里我们将偏置改为b=0.4:25次: 1234567891011121314151617181920(0.4, 0.6, 0.4)(0.4, 0.6, 0.4)(0.4, 0.6, 0.4)(0.4, 0.6, 0.39)(0.4, 0.6, 0.39)(0.4, 0.6, 0.39)(0.4, 0.6, 0.39)(0.4, 0.6, 0.38)(0.4, 0.6, 0.38)(0.4, 0.6, 0.38).......省略........(0.4, 0.6, 0.16999999999999982)(0.4, 0.6, 0.16999999999999982)(0.4, 0.6, 0.16999999999999982)(0.4, 0.6, 0.16999999999999982)(0.4, 0.6, 0.1599999999999998)('1 and 1 =', 1)('0 and 1 =', 1)('1 and 0 =', 1)('0 and 0 =', 1) 50次: 123456789101112131415161718(0.4, 0.6, 0.4)(0.4, 0.6, 0.4)(0.4, 0.6, 0.4)(0.4, 0.6, 0.39)(0.4, 0.6, 0.39)(0.4, 0.6, 0.39)(0.4, 0.6, 0.39)(0.4, 0.6, 0.38).......省略........(0.4, 0.6, -1.97758476261356e-16)(0.4, 0.6, -1.97758476261356e-16)(0.4, 0.6, -1.97758476261356e-16)(0.4, 0.6, -1.97758476261356e-16)(0.4, 0.6, -1.97758476261356e-16)('1 and 1 =', 1)('0 and 1 =', 1)('1 and 0 =', 1)('0 and 0 =', 0) 参考:感知器(维基百科)零基础入门深度学习(1) - 感知器]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang实现socks5代理连接]]></title>
    <url>%2Fposts%2Fc7816edc%2F</url>
    <content type="text"><![CDATA[socks5运行流程如下: 本机和代理服务端协商和建立连接； 本机告诉代理服务端目标服务的地址； 代理服务端去连接目标服务，成功后告诉本机； 本机开始发送原本应发送到目标服务的数据给代理服务端，由代理服务端完成数据转发。 先进行TCP连接golang实现(这里的地址我是本地socks5服务端) 12345conn,err := net.Dial("tcp","127.0.0.1:1080")if err != nil&#123; fmt.Println(err) return&#125; 向socks5服务端发送验证验证字段: VER NMETHODS METHODS 1字节 1字节 1-255字节 VER是SOCKS版本，这里应该是0x05； NMETHODS是METHODS部分的长度； METHODS是客户端支持的认证方式列表，每个方法占1字节。当前的定义是： 0x00 不需要认证 0x01 GSSAPI 0x02 用户名、密码认证 0x03 - 0x7F由IANA分配（保留） 0x80 - 0xFE为私人方法保留 0xFF 无可接受的方法 golang实现代码: 123456789_,err = conn.Write([]byte&#123;5,1,0&#125;)var b [2]bytestatus,err := conn.Read(b[:])if err!=nil&#123; fmt.Println(err) return&#125;fmt.Println(b)fmt.Println(status) 向socks5服务端发送请求请求字段: VER CMD RSV ATYP DST.ADDR DST.PORT 1字节 1字节 0x00 1字节 动态 2字节 - VER是SOCKS版本，这里应该是0x05； - CMD是SOCK的命令码 - 0x01表示CONNECT请求 - 0x02表示BIND请求 - 0x03表示UDP转发 - RSV 0x00，保留 - ATYP DST.ADDR类型 - 0x01 IPv4地址，DST.ADDR部分4字节长度 - 0x03 域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\0结尾。 - 0x04 IPv6地址，16个字节长度。 - DST.ADDR 目的地址 - DST.PORT 网络字节序表示的目的端口 golang实现代码 1234567891011121314151617181920212223domain := "www.google.com"before := []byte&#123;5,1,0,3,byte(len(domain))&#125;de := []byte(domain)port := []byte&#123;0x1,0xbb&#125;head_temp := append(before,de...)head := append(head_temp,port...)fmt.Println(head)_,err = conn.Write(head)if err!=nil&#123; fmt.Println(err) return&#125;var c [10]bytestatus_2,err := conn.Read(c[:])if err!=nil&#123; fmt.Println(err) return&#125;fmt.Println(status_2)fmt.Println(c) 进行数据转发golang实现代码(不太熟悉各种请求这里随便弄了一个) 12345678910111213141516_,err = conn.Write([]byte("GET /generate_204/ HTTP/2.0\r\n"))if err!=nil&#123; fmt.Println(err) return&#125;var d [1024]bytetemp := time.Now()status_3,err := conn.Read(d[:]) deply := time.Since(temp)fmt.Println(deply)fmt.Println(status_3)fmt.Println(string(d[:])) 关闭TCP连接1conn.Close() 参考来源SOCKS(维基百科)SOCKS5 协议介绍]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>scoks5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓通过adb添加电池用户白名单]]></title>
    <url>%2Fposts%2F1e63e0e%2F</url>
    <content type="text"><![CDATA[安卓6.0引入了doze来节省电量,但某些国产ui(如锤子)阉割了这个菜单,可通过adb添加 添加应用到白名单： 1adb shell dumpsys deviceidle whitelist +&lt;package&gt; 如: 1adb shell dumpsys deviceidle whitelist +com.google.android.gms 删除白名单(把加号改成减号): 1adb shell dumpsys deviceidle whitelist -&lt;package&gt; 查看doze状态： 1adb shell dumpsys deviceidle 获取完整的帮助菜单: 1adb shell dumpsys deviceidle -h 1234567891011121314151617181920212223242526272829303132Device idle controller (deviceidle) commands: help Print this help text. step [light|deep] Immediately step to next state, without waiting for alarm. force-idle [light|deep] Force directly into idle mode, regardless of other device state. force-inactive Force to be inactive, ready to freely step idle states. unforce Resume normal functioning after force-idle or force-inactive. get [light|deep|force|screen|charging|network] Retrieve the current given state. disable [light|deep|all] Completely disable device idle mode. enable [light|deep|all] Re-enable device idle mode after it had previously been disabled. enabled [light|deep|all] Print 1 if device idle mode is currently enabled, else 0. whitelist Print currently whitelisted apps. whitelist [package ...] Add (prefix with +) or remove (prefix with -) packages. except-idle-whitelist [package ...|reset] Prefix the package with '+' to add it to whitelist or '=' to check if it is already whitelisted [reset] will reset the whitelist to it's original state Note that unlike &lt;whitelist&gt; cmd, changes made using this won't be persisted across boots tempwhitelist Print packages that are temporarily whitelisted. tempwhitelist [-u USER] [-d DURATION] [package ..] Temporarily place packages in whitelist for DURATION milliseconds. If no DURATION is specified, 10 seconds is used]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓使用dalvikvm运行java(termux运行java)]]></title>
    <url>%2Fposts%2F8b98169e%2F</url>
    <content type="text"><![CDATA[一直想要使用termux来在安卓上写java,但termux上只有ecj可以使java编译为目标文件class,却不能使其编译为可执行文件发现通过安卓自带的dalvikvm可以运行,只是步骤繁琐一些 安装所需工具termux上安装 ecj 和 dx就可以了 1apt install ecj dx 编译为class文件1ecj XXX.java 编译成dex文件1dx --dex --output=XXX.dex XXX.class 使用dalvikvm运行1dalvikvm -cp XXX.dex XXX 参考: 使用 dalvikvm 执行一个运行于命令行的 Hello World]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用CIDR表示网段]]></title>
    <url>%2Fposts%2Fe2b25bb8%2F</url>
    <content type="text"><![CDATA[我们知道一般CIDR(无类别域间路由)网段的表示为:192.168.0.0/24这种形式 IP地址首先我们得知道ip地址是如何来的ipv4的地址是用32位二进制数表示的如: 255.255.255.0 -&gt; 11111111.11111111.11111111.00000000 网络前缀192.168.0.0/24中的24就是网络前缀,网络前缀可转化为网络掩码,24表示网络掩码的前24位为1 网络掩码「网络掩码」又叫「子网掩码」、「地址掩码」、「子網路遮罩」（subnet mask），它是一种用来指明一个IP地址的哪些位标识的是主机所在的网络地址以及哪些位标识的是主机地址的位掩码。 –维基百科 将网络前缀转化为网络掩码: 24 -&gt; 11111111.11111111.11111111.00000000 -&gt; 255.255.255.0255.255.255.0就是网络掩码 CIDR网络地址的计算方法为ip地址与网络掩码进行’与’运算通过上面的计算好的网络掩码可知这个ip地址的前24位是不变的 ,所以192.168.0.0/24表示的网段为: 192.168.0.0 - 192.168.0.255]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>IP</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android dumpsys tool]]></title>
    <url>%2Fposts%2F25303996%2F</url>
    <content type="text"><![CDATA[查看dumpsys所有的子命令: 1dumpsys | grep "DUMP OF SERVICE" output: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849DUMP OF SERVICE SurfaceFlinger:DUMP OF SERVICE accessibility:DUMP OF SERVICE account:DUMP OF SERVICE activity:DUMP OF SERVICE alarm:DUMP OF SERVICE appwidget:DUMP OF SERVICE audio:DUMP OF SERVICE backup:DUMP OF SERVICE battery:DUMP OF SERVICE batteryinfo:DUMP OF SERVICE clipboard:DUMP OF SERVICE connectivity:DUMP OF SERVICE content:DUMP OF SERVICE cpuinfo:DUMP OF SERVICE device_policy:DUMP OF SERVICE devicestoragemonitor:DUMP OF SERVICE diskstats:DUMP OF SERVICE dropbox:DUMP OF SERVICE entropy:DUMP OF SERVICE hardware:DUMP OF SERVICE input_method:DUMP OF SERVICE iphonesubinfo:DUMP OF SERVICE isms:DUMP OF SERVICE location:DUMP OF SERVICE media.audio_flinger:DUMP OF SERVICE media.audio_policy:DUMP OF SERVICE media.player:DUMP OF SERVICE meminfo:DUMP OF SERVICE mount:DUMP OF SERVICE netstat:DUMP OF SERVICE network_management:DUMP OF SERVICE notification:DUMP OF SERVICE package:DUMP OF SERVICE permission:DUMP OF SERVICE phone:DUMP OF SERVICE power:DUMP OF SERVICE reboot:DUMP OF SERVICE screenshot:DUMP OF SERVICE search:DUMP OF SERVICE sensor:DUMP OF SERVICE simphonebook:DUMP OF SERVICE statusbar:DUMP OF SERVICE telephony.registry:DUMP OF SERVICE throttle:DUMP OF SERVICE usagestats:DUMP OF SERVICE vibrator:DUMP OF SERVICE wallpaper:DUMP OF SERVICE wifi:DUMP OF SERVICE window: eg:1.得到电池的所有信息 1adb shell dumpsys battery 2.得到wifi的所有信息 1adb shell dumpsys wifi 3.得到cpu的所有信息 1adb shell dumpsys cpuinfo 4.得到总的存储情况 1adb shell dumpsys meminfo 5.得到某应用的存储情况 1adb shell dumpsys meminfo 'your apps package name' 6.得到所有的服务列表 1adb shell service list 7.得到所有的账户列表 1adb shell dumpsys account 8.获得某子命令的帮助信息 1adb shell dumpsys account -h 参考:What’s the Android ADB shell “dumpsys” tool and what are its benefits?]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓通过shell更改语言]]></title>
    <url>%2Fposts%2Ff7f814df%2F</url>
    <content type="text"><![CDATA[对于Android M或更高版本，使用： 12setprop ro.product.locale xx-XXsetprop persist.sys.locale xx-XX xx是语言XX是国家改为日语为:xx=ja XX=JP 其他安卓版本: 123setprop persist.sys.language xxsetprop persist.sys.country XXsetprop ctl.restart zygote xx是语言XX是国家 Zygote进程运行时, 会初始化Dalvik虚拟机, 并运行它. Android的应用程序是由Java编写的, 它们不能直接运行在Linux上, 只能运行在Dalvik虚拟机中. 并且, 每个应用程序都运行在各自的虚拟机中, 应用程序每次运行都要重新初始化并启动虚拟机, 这个过程会消耗相当长时间, 是拖慢应用程序的原因之一. 因此, 在Android中, 应用程序运行前, 通过Zygote进程共享已运行的虚拟机的代码与内存信息, 缩短应用程序运行所耗费的时间. 也就是说, Zygote进程会事先将应用程序要使用的Android Framework中的类与资源加载到内存中, 并组织形成所用资源的链接信息. 这样, 新运行的Android应用程序在使用所需资源时不必每次形成资源的链接信息, 这样就大大提升了程序的运行时间. 参考:1.通过ADB更改设备语言2.初识Zygote进程]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决xfce4画面撕裂]]></title>
    <url>%2Fposts%2F38868ade%2F</url>
    <content type="text"><![CDATA[安装compton1sudo apt install compton 修改配置文件compton的配置文件在~/.config/compton.conf因为有些窗口的阴影有时候会变的很奇怪,大概你有可能需要修改一下,附上我的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223################################### Backend################################### Backend to use: "xrender" or "glx".# GLX backend is typically much faster but depends on a sane driver.backend = "glx";################################### GLX backend##################################glx-no-stencil = true;# GLX backend: Copy unmodified regions from front buffer instead of redrawing them all.# My tests with nvidia-drivers show a 10% decrease in performance when the whole screen is modified,# but a 20% increase when only 1/4 is.# My tests on nouveau show terrible slowdown.# Useful with --glx-swap-method, as well.glx-copy-from-front = false;# GLX backend: Use MESA_copy_sub_buffer to do partial screen update.# My tests on nouveau shows a 200% performance boost when only 1/4 of the screen is updated.# May break VSync and is not available on some drivers.# Overrides --glx-copy-from-front.# glx-use-copysubbuffermesa = true;# GLX backend: Avoid rebinding pixmap on window damage.# Probably could improve performance on rapid window content changes, but is known to break things on some drivers (LLVMpipe).# Recommended if it works.# glx-no-rebind-pixmap = true;# GLX backend: GLX buffer swap method we assume.# Could be undefined (0), copy (1), exchange (2), 3-6, or buffer-age (-1).# undefined is the slowest and the safest, and the default value.# copy is fastest, but may fail on some drivers,# 2-6 are gradually slower but safer (6 is still faster than 0).# Usually, double buffer means 2, triple buffer means 3.# buffer-age means auto-detect using GLX_EXT_buffer_age, supported by some drivers.# Useless with --glx-use-copysubbuffermesa.# Partially breaks --resize-damage.# Defaults to undefined.glx-swap-method = "undefined";################################### Shadows################################### Enabled client-side shadows on windows.shadow = true;# Don't draw shadows on DND windows.no-dnd-shadow = true;# Avoid drawing shadows on dock/panel windows.no-dock-shadow = true;# Zero the part of the shadow's mask behind the window. Fix some weirdness with ARGB windows.#clear-shadow = true;# The blur radius for shadows. (default 12)shadow-radius = 5;# The left offset for shadows. (default -15)shadow-offset-x = -5;# The top offset for shadows. (default -15)shadow-offset-y = -5;# The translucency for shadows. (default .75)shadow-opacity = 0.5;# Set if you want different colour shadows# shadow-red = 0.0;# shadow-green = 0.0;# shadow-blue = 0.0;# The shadow exclude options are helpful if you have shadows enabled. #Due to the way compton draws its shadows, certain applications will have visual glitches# (most applications are fine, only apps that do weird things with xshapes or argb are affected).# This list includes all the affected apps I found in my testing. #The "! name~=''" part excludes shadows on any "Unknown" windows, this prevents a visual glitch with the XFWM alt tab switcher.#此处加入排除阴影的程序名字shadow-exclude = [ "! name~=''", "name = 'Notification'", "name = 'Plank'", "name = 'Docky'", "name = 'Kupfer'", "name = 'xfce4-notifyd'", "name *= 'VLC'", "name *= 'compton'", "name *= 'gedit'", "name *= 'Archive Manager'",# "name *= 'Chromium'",# "name *= 'Chrome'",# "name *= 'Firefox'", "class_g = 'Conky'", "class_g = 'Kupfer'", "class_g = 'Synapse'", "class_g ?= 'Notify-osd'", "class_g ?= 'Cairo-dock'", "class_g ?= 'Xfce4-notifyd'", "class_g ?= 'Xfce4-power-manager'"];# Avoid drawing shadow on all shaped windows (see also: --detect-rounded-corners)shadow-ignore-shaped = false;################################### Opacity##################################################################### Fading################################### Fade windows during opacity changes.fading = true;# The time between steps in a fade in milliseconds. (default 10).fade-delta = 4;# Opacity change between steps while fading in. (default 0.028).#fade-in-step = 0.03;# Opacity change between steps while fading out. (default 0.03).#fade-out-step = 0.03;# Fade windows in/out when opening/closing#no-fading-openclose = true;# Specify a list of conditions of windows that should not be faded.#fade-exclude = [ ];fade-exclude = [ ];################################### Other################################### Try to detect WM windows and mark them as active.mark-wmwin-focused = true;# Mark all non-WM but override-redirect windows active (e.g. menus).mark-ovredir-focused = true;# Use EWMH _NET_WM_ACTIVE_WINDOW to determine which window is focused instead of using FocusIn/Out events.# Usually more reliable but depends on a EWMH-compliant WM.use-ewmh-active-win = true;# Detect rounded corners and treat them as rectangular when --shadow-ignore-shaped is on.detect-rounded-corners = true;# Detect _NET_WM_OPACITY on client windows, useful for window managers not passing _NET_WM_OPACITY of client windows to frame windows.# This prevents opacity being ignored for some apps.# For example without this enabled my xfce4-notifyd is 100% opacity no matter what.#detect-client-opacity = true;# Specify refresh rate of the screen.# If not specified or 0, compton will try detecting this with X RandR extension.refresh-rate = 0;# Set VSync method. VSync methods currently available:# none: No VSync# drm: VSync with DRM_IOCTL_WAIT_VBLANK. May only work on some drivers.# opengl: Try to VSync with SGI_video_sync OpenGL extension. Only work on some drivers.# opengl-oml: Try to VSync with OML_sync_control OpenGL extension. Only work on some drivers.# opengl-swc: Try to VSync with SGI_swap_control OpenGL extension. Only work on some drivers. #Works only with GLX backend. Known to be most effective on many drivers. #Does not actually control paint timing, only buffer swap is affected, #so it doesn’t have the effect of --sw-opti unlike other methods. Experimental.# opengl-mswc: Try to VSync with MESA_swap_control OpenGL extension. Basically the same as opengl-swc above, except the extension we use.# (Note some VSync methods may not be enabled at compile time.)vsync = "opengl-swc";# Enable DBE painting mode, intended to use with VSync to (hopefully) eliminate tearing.# Reported to have no effect, though.dbe = false;# Painting on X Composite overlay window. Recommended.paint-on-overlay = true;# Limit compton to repaint at most once every 1 / refresh_rate second to boost performance.# This should not be used with --vsync drm/opengl/opengl-oml as they essentially does --sw-opti's job already,# unless you wish to specify a lower refresh rate than the actual value.sw-opti = false;# Unredirect all windows if a full-screen opaque window is detected, to maximize performance for full-screen windows, like games.# Known to cause flickering when redirecting/unredirecting windows.# paint-on-overlay may make the flickering less obvious.unredir-if-possible = false;# Specify a list of conditions of windows that should always be considered focused.focus-exclude = [ ];# Use WM_TRANSIENT_FOR to group windows, and consider windows in the same group focused at the same time.detect-transient = true;# Use WM_CLIENT_LEADER to group windows, and consider windows in the same group focused at the same time.# WM_TRANSIENT_FOR has higher priority if --detect-transient is enabled, too.detect-client-leader = true;################################### Window type settings##################################wintypes:&#123; tooltip = &#123; # fade: Fade the particular type of windows. fade = true; # shadow: Give those windows shadow shadow = false; # opacity: Default opacity for the type of windows. opacity = 0.85; # focus: Whether to always consider windows of this type focused. focus = true; &#125;;&#125;; 关闭xfce4自带的合成器设置管理器-&gt;窗口管理器微调-&gt;合成器 启动compton前台运行1compton 后台运行1compton -b 开机自启动修改~/.xprofile文件将compton -b直接加到新的一行就行了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>xfce4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下intel&AMD双显卡切换]]></title>
    <url>%2Fposts%2F3b8b96de%2F</url>
    <content type="text"><![CDATA[使用xrandr显示可支持的显卡 1xrandr --listproviders 输出类似以下内容 123Providers: number : 2Provider 0: id: 0x6b cap: 0x9, Source Output, Sink Offload crtcs: 3 outputs: 7 associated providers: 1 name:modesettingProvider 1: id: 0x41 cap: 0x6, Sink Output, Source Offload crtcs: 2 outputs: 0 associated providers: 1 name:OLAND @ pci:0000:01:00.0 To be able to render GPU-intensive applications by the more powerful discrete card use 1xrandr --setprovideroffloadsink 1 0 或者 1xrandr --setprovideroffloadsink 0x41 0x6b 使用DRI_PRIME为某个应用选择使用哪一张显卡,使用glxinfo可以查看正在使用的显卡 12DRI_PRIME=0 glxinfo | grep "OpenGL renderer"DRI_PRIME=1 glxinfo | grep "OpenGL renderer" 如为steam启用独显 1DRI_PRIME=1 steam 参考资料: 1.Intel/AMD Hybrid graphics Ubuntu 18.04 2.PRIME (简体中文)]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>双显卡</tag>
        <tag>amd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python使用lxml分析网页]]></title>
    <url>%2Fposts%2F77d15527%2F</url>
    <content type="text"><![CDATA[首先得引入lxml 12345#xpath为frome lxml import etree#cssselector为import lxml.html#cssselector使用起来简单但功能比xpath少 cssselector 12345678910111213tree = lxml.html.fromstring('你获取的网页源代码文件或变量')css = tree.cssselect('要选择的内容')#例如tree.cssselect('div.word-info &gt; div.pronounces &gt; span.word-audio')#选择器选择的结果为listcss.text_content()#表示选择的内容css.attrib['要表示的标签属性']#如css.attrb['class']表示的就是所选择内容的class属性 如果选择的内容换行符太多可以使用split表示成list去除 说明 例子 选择所有标签 * 选择&lt;a&gt;标签 a 选择所有class=”link”的标签 .link 选择class=”link”的&lt;a&gt;标签 a.link 选择id=”home”的&lt;a&gt;标签 a#home 选择父元素为&lt;a&gt;标签的所有&lt;span&gt;标签 a &gt; span 选择&lt;a&gt;标签内部的所有&lt;span&gt;标签 a span 选择title属性为”Home”的所有&lt;a&gt;标签 a[title=Home] xpath 1234selector=etree.HTML('你获取的网页源代码文件或变量')css = selector.xpath('要选择的内容')#xpath可直接表示#xpath可选择并表示属性 xpath由于内容太多,可以直接参考官方文档]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python获取网页源码(爬虫?)]]></title>
    <url>%2Fposts%2Fcee10602%2F</url>
    <content type="text"><![CDATA[利用requrst,使用首先要 1import requests 使用方法 123url = '要获取的网页地址'useragent = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36'#user-agent 可有可无,有些网页防爬虫就要模拟浏览器requests.get(url,headers=&#123;'User-Agent':useragent&#125;))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[snap删除旧的core(snap删除其他版本的软件)]]></title>
    <url>%2Fposts%2Fb6b8953%2F</url>
    <content type="text"><![CDATA[偶尔发现snap会自动升级core且不删除旧版，在’/snap/core’会发现好几个版本的文件夹。使用 1sudo snap remove core --revision xxx 删除某个版本的core，xxx是软件的rev，使用 1snap list 可以查看软件的rev，其他软件也能用这个方法删除旧的版本哦。 参考：How to unmount and possibly delete old Ubuntu Core snap]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>snap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu终端下连接wifi]]></title>
    <url>%2Fposts%2Ffb6d8628%2F</url>
    <content type="text"><![CDATA[首先使用rfkill查看你的wifi设备是否被停用使用命令 1rfkill list 获得设备列表，每个都包含与之关联的索引号，从 0 开始查看设备是否被停用，要启用被停用的设备，请运行： 1rfkill unblock &lt;索引号&gt; 要启用所有设备，请运行： 1rfkill unblock all 您可以使用这个索引号让 rfkill 停使或者使用某个设备，例如： 1rfkill block 0 您还可以使用 rfkill 阻断某一类设备，或者所有启用了RFKill的设备。例如： 1rfkill block wifi 停用系统中的所有Wi-Fi设备 启用无线网卡1ifconfig wlan0 up 使用iwconfig命令搜索无线网1iwlist wlan0 scan 记下essid连接无密码的无线网 1iwconfig wlan0 essid essidname 其中essidname是搜索到的无线网essid连接有密码的无线网 1iwconfig wlan0 essid essidname key &lt;密码&gt; 补充通过dhcp获取IP 1dhclient wlan0 或 1dhcpcd wlan0]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暗影精灵更改efi启动顺序]]></title>
    <url>%2Fposts%2F6683eff9%2F</url>
    <content type="text"><![CDATA[–2019-04-22 更新–最新版bios已经可以调整启动顺序了(图在最下面) ——– 之 前 ——-暗影精灵安装完ubuntu之后只能开机按esc+f9进入ubuntu，否则会直接启动windows,虽然可以使用但及其不方便的说 首先从ubuntu进入/boot/efi/EFI备份windwos的启动文件（切记一定要备份，否则只能从pe重新建立windwos启动项） 1cp -arf Microsoft win10 将ubuntu的grubx64.efi替换掉EFI/Microsoft/Boot/bootmgfw.efi文件 1cp -arf ubuntu/grubx64.efi Microsoft/Boot/bootmgfw.efi 这样替换之后grub就接管了系统的启动 然后将/boot/grub/grub.cfg中关于windows的启动段复制到/etc/grub.d/40_custom中将chainloader /EFI/Micorosoft/Boot/bootmgfw.efi改为chainloader /EFI/win10/Boot/bootmgfw.efi就是把中间那个改为你备份的文件夹，可以改一改前面的启动名称最后执行update-grub来更新启动项 但是windwos有大更新的时候会把更改的覆盖掉，再来一遍就好了 参考文章暗影精灵2pro安装win10+ubuntu16.10双系统]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>EFI</tag>
        <tag>BIOS</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[関西弁コレクション]]></title>
    <url>%2Fposts%2Fa4241e7%2F</url>
    <content type="text"><![CDATA[平常看到的関西弁会在这里记录–2019年2月1日– ①関西弁の～ねんけど、～やねん、～ねんの意味を教えて下さい②～ねやは～ですかの意味ですか？それ意外に意味、使い方等は有りますか？③言葉の関西弁のアクセントを教えて下さい ①・・・～ねんけど ですけれど（〇〇なんですけれど）～やねん、～ねん です（〇〇なんです） ②・・・～ねやは～（～やねん”わ”～ですね。）〇○なんですよ。 ③・・・～ねんけど（中中）～やねん（高低）～やねんわ～（高低中） 関西弁で、「あんねんけど」と「あるねんけど」の違いはなんですか？ 意味の違いはない。「あるねんけど」＝「あんねんけど」 「る」が撥音化して「ん」になっただけ。日本語では語中の「ラ行音」が「ん」に変化する傾向がある。・それで→そんで・分からない→分かんない –2018年12月8日– せやからアカンてゆうたやろせやから 別表記：そやから「だから」の意味。主に関西地方で用いる。「そやから」ともいう。 アカン(あかん)関西弁で「ダメ」の意味。 『ゆうて』は『～言って』 ##方言で だから ダメって 言ったでしょ –2018年8月29日– ビビり【名词】1.颤动，振纹（机械）2.胆小，大阪方言。関西弁 女子|假名:おなご 【名词】1.女孩，女孩子。2.妇女，女子。3.女仆，该说法多用于关西地区。详细解释: 名词 女孩，女孩子。（女の子、女児）。 妇女，女子。（女の人、女性、婦人）。 女仆，该说法多用于关西地区。（召し使いの女、女中、はしため）。 –2018年8月7日更新– それアカンやつや一字一句、分けてみましょう。「それ、アカン、やつ、や」になります。「それ」はthatのことですよね。「アカン」はNOのことです。その通り、関西弁です。「やつ」は奴のことです。人を愚弄する言い方ですね。でも人以外に、ものに対しても指す場合があります。「や」も関西弁です。これを東京の人が話すと「それはいけない人だよね～」や「それはありえないよね～」という言い方になります。元ネタを想像すると、ここでは「やつ」はものを指していると思います。 せ や な同意を表明する語。関西弁。「そうだね」、「そうだな」などに相当する。 しんどい 【形容词/イ形容词】1.日本关西方言，费劲，吃力。累。疲劳。源自:《现代日汉双解词典》外教社 形容词/イ形容词 骨が折れる。難儀だ。麻烦。费劲。 この仕事はしんどい。这个工作费劲（麻烦）。 くたびれている。疲乏。劳累。疲劳。 しんどくてもこの仕事をやってしまおう。即使累，也要把这个工作干完。 おお，しんどい。好累！ ほんま 【本真】（ 名 ・形動 ）本当である・こと（さま）。真実。主に関西地方で用いる。 「 －の話やで」 「 －に驚いたわ」 しゃあない【方言】 ;大阪话。没办法、没辙了。（大阪弁で「しかたない」の意味である。） アカン感叹词不行，不可以。（（「埒らち明かぬ」の略。多く関西で使う）うまくいかない。だめだ。不可である。） アホやん跟冒失娘（ドジっ娘）类似，关西方言 冒失娘（ドジっ娘），萌属性之一。此属性以女性为主，若是男性可用较中性的“ドジっ子”。日文“どじ”或“どぢ”是指人或事的出错和失误。“ドジっ娘”就是指经常弄翻物件、行事笨拙、“大错不出，小错不断”，总是搞出呆呆笨笨事情的少女。中文意译的“冒失”，是指做事有漏失，而不是为人鲁莽无礼的意思。どじっ应该不写成汉字参考自维基百科]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>関西弁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript对字符串操作]]></title>
    <url>%2Fposts%2F86cfa6a%2F</url>
    <content type="text"><![CDATA[1234var name='aaaa';var age='bbbb';var change='Hello javascript';var message=`hello,$&#123;name&#125;,$&#123;age&#125;,`+name+age;//将多个字符串写成一句话 1var length=message.length;//获取字符串长度 1var upper=message.toUpperCase();//把字符串全部变成大写 1var lower=message.toLowerCase();//把字符串全部变成小写 1var search=message.indexOf('aaaa');//搜索字符串位置 1var substr=message.substring(9, 15);//返回区间内字符串 12x=document.getElementById("test"); //查找元素x.innerHTML="Hello JavaScript"; //改变内容]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让win10的UWP应用走代理]]></title>
    <url>%2Fposts%2Fd22ffdb6%2F</url>
    <content type="text"><![CDATA[原因因为uwp应用的特殊性,即使使用proxifier和proxycap这种应用者无法让其走代理 1.SSTAP这个应用是创建虚拟网卡,让windows全局走代理.但其有弊端就是有一些国内的网站也会走代理,比如BILIBILI.虽然可以自己写规则但实在是麻烦无比. 2.fiddler利用fiddler的winconfig实现uwp应用走代理把要走代理的应用勾上但这不是全局代理,只能让uwp应用走代理]]></content>
      <categories>
        <category>使用技巧</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言数组输出的另一种方法]]></title>
    <url>%2Fposts%2F854ed6ec%2F</url>
    <content type="text"><![CDATA[今天看到这样一种写法,原文链接:一个有趣的C语言程序 123456789#include &lt;stdio.h&gt; int main()&#123; int a = 1; int x[5]=&#123;1,2,3,4,5&#125;; printf("%d",a[x]); return 0;&#125; 1output: 2 int x[5],x实际上保存的是这个数组首元素的地址也就是&amp;x[0].a[x]的等效写法是*(a+&amp;x).因为上面说了x实际上是x[0].所以可以进一步写成*(a+&amp;x[0]),又因为a=1所以可以替换成*(&amp;x[0]+1),也就是x[1].所以就是x[1]对应的值：2 由此我又想到了二位数组 123456789#include &lt;stdio.h&gt; int main()&#123; int a = 1; int x[2][2]=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;; printf("%d",a[a[x]]); return 0;&#125; 1output: 4 感觉好神奇,而且在之前不知道在哪看到c语言的数组其实就是指针的合集,而且最近要用链表,更觉得链表和数组差不多.]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用结构体让函数返回多个值]]></title>
    <url>%2Fposts%2Fc69434f1%2F</url>
    <content type="text"><![CDATA[c语言123456789101112131415161718192021222324#include "stdio.h"typedef struct test //建立结构体&#123; int a; int b; int c;&#125;T;T testt(int aa,int bb,int cc) //建立函数&#123; T aaa; aaa.a=aa*bb; aaa.b=aa*cc; aaa.c=bb*cc; return aaa; //返回结构&#125;int main()&#123; T b=testt(4,5,6); printf("%d %d %d \n",b.a,b.b,b.c); T *f=&amp;b; printf("%d %d %d",f-&gt;a,f-&gt;b,f-&gt;c);&#125; C++ 123456789101112131415161718192021222324252627#include "iostream"typedef struct sss //建立结构体&#123; int a; int b; int c;&#125;S;S s(double a,double b,double c) 建立函数&#123; S d; d.a=a*a; d.b=b*b; d.c=c*c; return d;//返回结构体&#125;int main()&#123; S z=s(3,4,5); std::cout&lt;&lt;z.a &lt;&lt;std::endl &lt;&lt;z.b &lt;&lt;std::endl &lt;&lt;z.c &lt;&lt;std::endl;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>编程</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言基本类型在内存中的存储方式]]></title>
    <url>%2Fposts%2Fe404489%2F</url>
    <content type="text"><![CDATA[浮点数float 符号位 + 指数位 + 尾数位 ↑ ↑ ↑ 第一位 8位 23位 double 符号位 + 指数位 + 尾数位 ↑ ↑ ↑ 第一位 11位 52位 整数整数在内存中是以补码的形式存储 正整数原码=反码=补码 负整数原码即为原码反码=原码符号为不变,其余取反(注:第一位为符号位)补码=反码+1 2019年4月3日更新原码范围: 整数:(1111…1) $-(2^n-1) \leq x \leq 2^n-1$ (01111…1) 小数:(1.111…1) $-(1-2^n) \leq x \leq 1-2^{-n}$ (0.111…1)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java和c++简单的递归调用]]></title>
    <url>%2Fposts%2F5eb800c7%2F</url>
    <content type="text"><![CDATA[题目是盗来的 12345678猴子吃桃问题。猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第n天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少桃子。例如：输入：3输出：10输入：10输出：1534 C++: 12345678910111213141516171819202122232425#include "iostream"using namespace std;long long d(int);int main(int argc, char const *argv[])&#123; int a; cin&gt;&gt;a; cout&lt;&lt;d(a)&lt;&lt;endl; return 0;&#125;long long d(int a)&#123; long long e; if(a==1) &#123; e=1; &#125; else if(a&gt;1) &#123; e=(d(a-1)+1)*2; &#125; return e;&#125; java: 12345678910111213141516171819202122232425import java.util.*;public class dgcs&#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int a=in.nextInt(); System.out.println(f(a)); &#125; public static long f(int a) &#123; long e; if(a==1) &#123; e=1; &#125; else &#123; e=(f(a-1)+1)*2; &#125; return e; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>c++</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言利用char指针变量将int按字节打印地址]]></title>
    <url>%2Fposts%2F43cb2931%2F</url>
    <content type="text"><![CDATA[因为int变量的大小为四个字节,所以如果利用int指针变量+1输出地址的话,实际上是加了四个字节后的地址.而char的大小刚好为一个字节,是我们想要的东西.这样我们可以强制转换为char指针变量输出每个字节的地址然后+1,+2,+3来分别输出int的四个字节的地址,得到我们想要的内容.代码如下 123int a=-65;char *b=(char *)&amp;a;printf("%p\n%p\n%p\n%p\n",a,a+1,a+2,a+3); 如果你想按字节输出内存中的内容可以这样写,这里我输出的是16进制整数. 123int a=-65;char *b=(char *)&amp;a;printf("%02x\n%02x\n%02x\n%02x\n",*(unsigned char*)a,*(unsigned char*)(a+1),*(unsigned char*)(a+2),*(unsigned char*)(a+3)); 两者结合一下 123int a=-65;char *b=(char *)&amp;a;printf("%p %02x\n%p %02x\n%p %02x\n%p %02x\n",a,*(unsigned char*)a,a+1,*(unsigned char*)(a+1),a+2,*(unsigned char*)(a+2),a+3,*(unsigned char*)(a+3)); 输出内容如图有任何错误请邮箱联系我指出我的错误,万分感谢]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言中格式化字符的应用]]></title>
    <url>%2Fposts%2Fb6b4601%2F</url>
    <content type="text"><![CDATA[格式化规定符符号 作用%d 十进制有符号整数%u 十进制无符号整数%f 浮点数%s 字符串%c 单个字符%p 指针的值%e 指数形式的浮点数%x, %X 无符号以十六进制表示的整数%0 无符号以八进制表示的整数%g 自动选择合适的表示法 说明:(1). 可以在”%”和字母之间插进数字表示最大场宽。例如: %3d 表示输出3位整型数, 不够3位右对齐。%9.2f 表示输出场宽为9的浮点数, 其中小数位为2, 整数位为6,小数点占一位, 不够9位右对齐。另外, 若想在输出值前加一些0, 就应在场宽项前加个0。例如: %04d 表示在输出一个小于4位的数值时, 将在前面补0使其总宽度为4位。如果用浮点数表示字符或整型量的输出格式, 小数点后的数字代表最大宽度,小数点前的数字代表最小宽度。例如: %6.9s 表示显示一个长度不小于6且不大于9的字符串。若大于9, 则第9个字符以后的内容将被删除。(2). 可以在”%”和字母之间加小写字母l, 表示输出的是长型数。例如: %ld 表示输出long整数,%lf 表示输出double浮点数(3). 可以控制输出左对齐或右对齐, 即在”%”和字母之间加入一个”-“ 号可说明输出为左对齐, 否则为右对齐。例如: %-7d 表示输出7位整数左对齐,%-10s 表示输出10个字符左对齐. 一些特殊规定字符字符 作用/n 换行/f 清屏并换页/r 回车/t Tab符/xhh 表示一个ASCII码用16进表示,其中hh是1到2个16进制数]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用等价无穷小的一般形式]]></title>
    <url>%2Fposts%2F10bb899d%2F</url>
    <content type="text"><![CDATA[当$\lim_{φ(x)\to0}$时,$\sin φ(x)$$φ(x)$$arc\sin φ(x)$$φ(x)$$\tanφ(x)$$φ(x)$$arc\tanφ(x)$$φ(x)$$\ln(1+φ(x))$$φ(x)$$e^{φ(x)}-1$$φ(x)$$a^{φ(x)}-1$$φ(x)\ln a$$\sqrt[n]{1+φ(x)}-1$$\frac{1}{n}φ(x)$$(1+φ(x))^{\mu-1}$$\muφ(x)$$1-\cosφ(x)$$\frac{(φ(x))^2}{2}$]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>公式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三蛋空间自建贴吧云签到]]></title>
    <url>%2Fposts%2F8a291f21%2F</url>
    <content type="text"><![CDATA[–这是我自建的贴吧云签到:http://dmly.tk(已失效)之后为教程 注册免费空间首先你得注册一个三蛋空间的账号,三蛋空间注册网址:三蛋空间 创建网站注册完成之后点击这里 添加一个空模版,如图 写上名字和密码,点击create ftp下载SmartFTP Client或者其他你熟悉的ftp上传工具,这里百度就行了进入三蛋空间的管理网站,点击这里,如图 把这里的信息填入SmartFTP Client中 然后点ok 上传贴吧云签到源码github地址:Tieba-Cloud-Sign点击这里下载zip并解压 将解压得到的所有文件拖入ftp上的public_html文件夹中 创建数据库然后进入三蛋空间创建数据库三蛋空间会自动给你的数据库名字前加上数字,所以之后在贴吧安装中要注意 安装之后进入你的网站,然后安装就行了. 创建cron job安装完成后就要把do.php加入cron,否则是不会自动签到的,按图中的步骤进行]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>建站</tag>
        <tag>免费</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更改绑定手机号]]></title>
    <url>%2Fposts%2F3fee5f2%2F</url>
    <content type="text"><![CDATA[绑定手机号：微信，网易云，淘宝原手机号及证件，支付宝，google银行卡，贴吧，酷安，微博需要原手机号，bilibili（需要原手机号)微软,欢喜云，京东（原手机号及银行卡，非我的实名认证）天猫，银行卡，steam，小冰，yy(需要原手机号)]]></content>
      <categories>
        <category>日常生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C输出字符串的ASCII码]]></title>
    <url>%2Fposts%2Fundefined%2F</url>
    <content type="text"><![CDATA[123456789101112#include &lt;stdio.h&gt;int main()&#123;char str[]=”This is a string!”;int i=0;while(str[i]!=’\0′)&#123;printf(“%c=%d\n”,str[i],str[i]);i++;&#125;printf(“%c=%d\n”,str[i],str[i]);&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
